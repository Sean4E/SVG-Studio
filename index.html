<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Studio Pro — Vector Editor & Image Tracer</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
:root {
    --bg-dark: #0a0a0f;
    --bg-panel: rgba(18, 18, 28, 0.85);
    --bg-input: rgba(30, 30, 45, 0.8);
    --bg-hover: rgba(50, 50, 70, 0.6);
    --border: rgba(255, 255, 255, 0.08);
    --border-hover: rgba(255, 255, 255, 0.15);
    --text: #e8e8ed;
    --text-dim: #8888a0;
    --text-bright: #ffffff;
    --accent: #6366f1;
    --accent-hover: #818cf8;
    --accent-glow: rgba(99, 102, 241, 0.3);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --glass-blur: 20px;
    --radius: 12px;
    --radius-sm: 8px;
    --radius-xs: 4px;
    --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    --font-main: 'Plus Jakarta Sans', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', monospace;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-main);
    background: var(--bg-dark);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
}

/* App Layout */
.app {
    display: grid;
    grid-template-rows: 48px 1fr;
    grid-template-columns: 280px 1fr 320px;
    height: 100vh;
}

/* Header */
.header {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    background: var(--bg-panel);
    backdrop-filter: blur(var(--glass-blur));
    border-bottom: 1px solid var(--border);
    z-index: 100;
}

.logo {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
    font-size: 15px;
    color: var(--text-bright);
}

.logo-icon {
    width: 28px;
    height: 28px;
    background: linear-gradient(135deg, var(--accent), #a855f7);
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
}

.mode-tabs {
    display: flex;
    gap: 4px;
    background: var(--bg-input);
    padding: 4px;
    border-radius: var(--radius);
}

.mode-tab {
    padding: 8px 20px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all 0.2s;
}

.mode-tab:hover {
    color: var(--text);
}

.mode-tab.active {
    background: var(--accent);
    color: white;
}

.header-actions {
    display: flex;
    gap: 8px;
}

/* Buttons */
.btn {
    padding: 8px 16px;
    border: 1px solid var(--border);
    background: var(--bg-input);
    color: var(--text);
    font-family: inherit;
    font-size: 13px;
    font-weight: 500;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 6px;
}

.btn:hover {
    background: var(--bg-hover);
    border-color: var(--border-hover);
}

.btn-primary {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}

.btn-primary:hover {
    background: var(--accent-hover);
    border-color: var(--accent-hover);
}

.btn-icon {
    width: 36px;
    height: 36px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
}

.btn-text {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 8px;
    font-size: 11px;
    cursor: pointer;
    transition: color 0.15s;
}

.btn-text:hover {
    color: var(--text);
}

/* Left Panel */
.left-panel {
    background: var(--bg-panel);
    backdrop-filter: blur(var(--glass-blur));
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.panel-section {
    padding: 16px;
    border-bottom: 1px solid var(--border);
}

.layers-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.section-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 12px;
}

/* Tools Grid */
.tools-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
}

.tool-btn {
    aspect-ratio: 1;
    border: 1px solid transparent;
    background: transparent;
    color: var(--text-dim);
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.tool-btn:hover {
    background: var(--bg-hover);
    color: var(--text);
}

.tool-btn.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.tool-btn svg {
    width: 18px;
    height: 18px;
}

/* Layers */
.layers-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.layer-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    margin-bottom: 4px;
    cursor: pointer;
    transition: all 0.15s;
}

.layer-item:hover {
    border-color: var(--border-hover);
}

.layer-item.selected {
    border-color: var(--accent);
    background: rgba(99, 102, 241, 0.1);
}

.layer-preview {
    width: 32px;
    height: 32px;
    background: var(--bg-dark);
    border-radius: var(--radius-xs);
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}

.layer-preview svg {
    width: 24px;
    height: 24px;
}

.layer-info {
    flex: 1;
    min-width: 0;
}

.layer-name {
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.layer-type {
    font-size: 10px;
    color: var(--text-dim);
}

.layer-actions {
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.15s;
}

.layer-item:hover .layer-actions {
    opacity: 1;
}

.layer-action-btn {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    border-radius: var(--radius-xs);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.layer-action-btn:hover {
    background: var(--bg-hover);
    color: var(--text);
}

.layer-visibility-btn {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    border-radius: var(--radius-xs);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    opacity: 0.5;
    transition: all 0.15s;
}

.layer-visibility-btn.visible {
    opacity: 1;
    color: var(--accent);
}

.layer-visibility-btn:hover {
    background: var(--bg-hover);
    opacity: 1;
}

.layer-item.hidden-layer {
    opacity: 0.5;
}

.layer-item.hidden-layer .layer-preview {
    opacity: 0.4;
}

/* Layer drag states */
.layer-item.dragging {
    opacity: 0.5;
    background: var(--accent);
}

.layer-item.drag-over {
    border-top: 2px solid var(--accent);
    margin-top: -1px;
}

.layer-item.drag-over-below {
    border-bottom: 2px solid var(--accent);
    margin-bottom: -1px;
}

.layer-drag-handle {
    cursor: grab;
    padding: 4px;
    opacity: 0.5;
    transition: opacity 0.15s;
}

.layer-drag-handle:hover {
    opacity: 1;
}

.layer-drag-handle:active {
    cursor: grabbing;
}

/* Disabled button state */
.btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    pointer-events: none;
}

/* Canvas Area */
.canvas-area {
    position: relative;
    background: #0d0d14;
    background-image: 
        linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
    background-size: 20px 20px;
    overflow: hidden;
}

.canvas-container {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.canvas-wrapper {
    position: relative;
    display: inline-block;
}

#mainCanvas {
    display: block;
    background: white;
    box-shadow: var(--shadow);
    border-radius: 4px;
}

#selectionCanvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
}

/* Zoom Controls */
/* Alignment Toolbar */
.align-toolbar {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    background: var(--bg-panel);
    backdrop-filter: blur(var(--glass-blur));
    border: 1px solid var(--border);
    border-radius: var(--radius);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
}

.align-toolbar.visible {
    opacity: 1;
    pointer-events: auto;
}

.align-toolbar .divider {
    width: 1px;
    height: 20px;
    background: var(--border);
    margin: 0 4px;
}

.align-btn {
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    border-radius: var(--radius-xs);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
}

.align-btn:hover {
    background: var(--bg-hover);
    color: var(--text);
}

.align-btn:active {
    transform: scale(0.95);
}

.align-btn svg {
    width: 16px;
    height: 16px;
}

/* Rulers */
.ruler {
    background: var(--bg-panel);
    position: absolute;
    z-index: 10;
}

.ruler-h {
    top: 0;
    left: 20px;
    right: 0;
    height: 20px;
    border-bottom: 1px solid var(--border);
}

.ruler-v {
    left: 0;
    top: 20px;
    bottom: 0;
    width: 20px;
    border-right: 1px solid var(--border);
}

.ruler-corner {
    position: absolute;
    top: 0;
    left: 0;
    width: 20px;
    height: 20px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    z-index: 11;
}

/* Guides */
.guide {
    position: absolute;
    background: #ff00ff;
    z-index: 5;
    pointer-events: auto;
    cursor: move;
}

.guide-h {
    height: 1px;
    left: 0;
    right: 0;
}

.guide-v {
    width: 1px;
    top: 0;
    bottom: 0;
}

.zoom-controls {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--bg-panel);
    backdrop-filter: blur(var(--glass-blur));
    border: 1px solid var(--border);
    border-radius: var(--radius);
}

.zoom-level {
    font-size: 12px;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
}

.cursor-coords {
    font-size: 11px;
    font-family: var(--font-mono);
    color: var(--text-dim);
    min-width: 90px;
}

/* Smart Guides */
.smart-guide {
    position: absolute;
    background: #ff00ff;
    z-index: 20;
    pointer-events: none;
}

.smart-guide-h {
    height: 1px;
    left: 0;
    right: 0;
}

.smart-guide-v {
    width: 1px;
    top: 0;
    bottom: 0;
}

.distance-label {
    position: absolute;
    background: #ff00ff;
    color: white;
    font-size: 10px;
    padding: 2px 4px;
    border-radius: 2px;
    white-space: nowrap;
    z-index: 21;
    pointer-events: none;
}

/* Right Panel */
.right-panel {
    background: var(--bg-panel);
    backdrop-filter: blur(var(--glass-blur));
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.right-panel-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
}

.panel-tab {
    flex: 1;
    padding: 12px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    font-family: inherit;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    border-bottom: 2px solid transparent;
}

.panel-tab:hover {
    color: var(--text);
}

.panel-tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
}

.right-panel-content {
    flex: 1;
    overflow-y: auto;
}

/* Properties */
.properties-section {
    padding: 16px;
    border-bottom: 1px solid var(--border);
}

.prop-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
}

.prop-row:last-child {
    margin-bottom: 0;
}

.prop-label {
    font-size: 11px;
    color: var(--text-dim);
    min-width: 50px;
}

.prop-input {
    flex: 1;
    height: 32px;
    padding: 0 10px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-xs);
    color: var(--text);
    font-family: var(--font-mono);
    font-size: 12px;
}

.prop-input:focus {
    outline: none;
    border-color: var(--accent);
}

.prop-input-sm {
    width: 70px;
    flex: none;
}

/* Property slider combo */
.prop-slider-combo {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
}

.prop-slider-combo input[type="range"] {
    flex: 1;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--border);
    border-radius: 2px;
    cursor: pointer;
}

.prop-slider-combo input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.15s;
}

.prop-slider-combo input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
}

.prop-slider-combo input[type="number"] {
    width: 55px;
    flex: none;
}

.prop-row-stacked {
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
}

.prop-row-stacked .prop-label {
    width: auto;
    margin-bottom: 2px;
}

/* Color Picker */
.color-picker-wrap {
    display: flex;
    align-items: center;
    gap: 8px;
}

.color-swatch {
    width: 32px;
    height: 32px;
    border-radius: var(--radius-xs);
    border: 2px solid var(--border);
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.color-swatch::before {
    content: '';
    position: absolute;
    inset: 0;
    background: conic-gradient(#808080 0deg 90deg, #fff 90deg 180deg, #808080 180deg 270deg, #fff 270deg);
    background-size: 8px 8px;
}

.color-swatch-inner {
    position: absolute;
    inset: 0;
}

.color-swatch-input {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.color-hex {
    flex: 1;
}

/* Color Presets */
.color-presets {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}

.color-preset {
    width: 24px;
    height: 24px;
    border-radius: var(--radius-xs);
    cursor: pointer;
    transition: all 0.15s;
}

.color-preset:hover {
    transform: scale(1.15);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* Gradient */
.gradient-preview {
    height: 48px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
    margin-bottom: 12px;
    position: relative;
    background: linear-gradient(90deg, #6366f1, #a855f7);
}

.gradient-stops {
    position: absolute;
    bottom: -8px;
    left: 0;
    right: 0;
    height: 16px;
}

.gradient-stop {
    position: absolute;
    width: 12px;
    height: 12px;
    background: white;
    border: 2px solid var(--bg-dark);
    border-radius: 50%;
    transform: translateX(-50%);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.gradient-stop.active {
    border-color: var(--accent);
    z-index: 1;
}

/* Code Panel */
.code-panel {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.code-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
}

.code-editor {
    flex: 1;
    background: var(--bg-dark);
    padding: 12px;
    font-family: var(--font-mono);
    font-size: 11px;
    line-height: 1.6;
    overflow: auto;
    white-space: pre-wrap;
    word-break: break-all;
    color: #a5d6ff;
}

.code-editor:focus {
    outline: none;
}

/* Mode Content Panels */
.create-mode-content,
.trace-mode-content,
.edit-mode-content {
    display: flex;
    flex-direction: column;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
}

.edit-mode-hint {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 20px 16px;
    margin: 8px;
    background: rgba(99, 102, 241, 0.08);
    border: 1px dashed var(--border);
    border-radius: var(--radius-sm);
    color: var(--text-secondary);
    font-size: 13px;
}

.edit-mode-hint.hidden {
    display: none;
}

.edit-mode-hint strong {
    color: var(--accent);
}

.create-mode-content.hidden,
.trace-mode-content.hidden,
.edit-mode-content.hidden {
    display: none !important;
}

.btn-group-vertical {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.btn-group-vertical .btn {
    width: 100%;
}

/* Trace Panel */
.trace-panel {
    padding: 16px;
}

.drop-zone {
    border: 2px dashed var(--border);
    border-radius: var(--radius);
    padding: 40px 20px;
    text-align: center;
    transition: all 0.2s;
    cursor: pointer;
}

.drop-zone:hover,
.drop-zone.dragover {
    border-color: var(--accent);
    background: rgba(99, 102, 241, 0.05);
}

.drop-zone-icon {
    width: 48px;
    height: 48px;
    margin: 0 auto 12px;
    color: var(--text-dim);
}

.drop-zone-text {
    font-size: 14px;
    color: var(--text);
    margin-bottom: 4px;
}

.drop-zone-hint {
    font-size: 12px;
    color: var(--text-dim);
}

.drop-zone.hidden {
    display: none;
}

.image-preview-container {
    position: relative;
    margin-bottom: 16px;
}

.image-preview {
    width: 100%;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
}

.remove-image-btn {
    position: absolute;
    top: 8px;
    right: 8px;
}

/* Trace Controls */
.trace-controls {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.control-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.control-label-text {
    font-size: 12px;
    font-weight: 500;
}

.control-value {
    font-size: 11px;
    color: var(--text-dim);
    font-family: var(--font-mono);
}

/* Range Slider */
input[type="range"] {
    width: 100%;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--bg-input);
    border-radius: 3px;
    outline: none;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
}

input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Toggle */
.toggle-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
}

.toggle-label {
    font-size: 12px;
}

.toggle {
    width: 44px;
    height: 24px;
    background: var(--bg-input);
    border-radius: 12px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
}

.toggle.active {
    background: var(--accent);
}

.toggle-handle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    transition: transform 0.2s;
}

.toggle.active .toggle-handle {
    transform: translateX(20px);
}

/* Palette */
.palette-display {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 12px;
    background: var(--bg-input);
    border-radius: var(--radius-sm);
    max-height: 120px;
    overflow-y: auto;
}

.palette-color {
    width: 24px;
    height: 24px;
    border-radius: var(--radius-xs);
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
}

.palette-color:hover {
    transform: scale(1.15);
}

/* Progress */
.progress-container {
    margin-top: 16px;
}

.progress-bar {
    height: 4px;
    background: var(--bg-input);
    border-radius: 2px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #a855f7);
    border-radius: 2px;
    transition: width 0.3s;
}

.progress-text {
    font-size: 11px;
    color: var(--text-dim);
    margin-top: 6px;
    text-align: center;
}

/* Modal */
.modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s;
}

.modal-overlay.active {
    opacity: 1;
    visibility: visible;
}

.modal {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 24px;
    width: 90%;
    max-width: 500px;
    box-shadow: var(--shadow);
    transform: scale(0.95);
    transition: transform 0.2s;
}

.modal-overlay.active .modal {
    transform: scale(1);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.modal-title {
    font-size: 18px;
    font-weight: 600;
}

.modal-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    border-radius: var(--radius-xs);
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    background: var(--bg-hover);
    color: var(--text);
}

/* Shortcuts styles */
.shortcuts-section {
    margin-bottom: 20px;
}

.shortcuts-section:last-child {
    margin-bottom: 0;
}

.shortcuts-title {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
}

.shortcut-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    font-size: 13px;
}

.shortcut-key {
    background: var(--bg-input);
    padding: 4px 8px;
    border-radius: var(--radius-xs);
    font-family: var(--font-mono);
    font-size: 11px;
    font-weight: 500;
    color: var(--accent);
    border: 1px solid var(--border);
    min-width: 70px;
    text-align: center;
}

.export-options {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    margin-bottom: 20px;
}

.export-option {
    padding: 16px;
    background: var(--bg-input);
    border: 2px solid var(--border);
    border-radius: var(--radius-sm);
    cursor: pointer;
    text-align: center;
    transition: all 0.2s;
}

.export-option:hover {
    border-color: var(--border-hover);
}

.export-option.selected {
    border-color: var(--accent);
    background: rgba(99, 102, 241, 0.1);
}

.export-option-icon {
    font-size: 24px;
    margin-bottom: 8px;
}

.export-option-name {
    font-size: 13px;
    font-weight: 600;
}

.export-option-desc {
    font-size: 11px;
    color: var(--text-dim);
    margin-top: 4px;
}

/* Select */
.select-wrap {
    position: relative;
}

select {
    width: 100%;
    height: 36px;
    padding: 0 32px 0 12px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-xs);
    color: var(--text);
    font-family: inherit;
    font-size: 13px;
    cursor: pointer;
    appearance: none;
}

select:focus {
    outline: none;
    border-color: var(--accent);
}

.select-arrow {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    color: var(--text-dim);
}

/* Context Menu */
.context-menu {
    position: fixed;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 6px;
    min-width: 180px;
    box-shadow: var(--shadow);
    z-index: 1000;
    display: none;
}

.context-menu.active {
    display: block;
}

.context-item {
    padding: 8px 12px;
    font-size: 13px;
    color: var(--text);
    border-radius: var(--radius-xs);
    cursor: pointer;
    transition: background 0.1s;
}

.context-item:hover {
    background: var(--bg-hover);
}

.context-separator {
    height: 1px;
    background: var(--border);
    margin: 6px 0;
}

/* Toast */
.toast-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.toast {
    padding: 12px 16px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 13px;
    animation: slideIn 0.3s ease;
    box-shadow: var(--shadow);
}

.toast-success {
    border-color: var(--success);
}

.toast-error {
    border-color: var(--danger);
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--border-hover);
}

/* Utilities */
.hidden {
    display: none !important;
}

/* Tab content */
.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Trace Status */
.trace-status {
    padding: 12px;
    background: rgba(99, 102, 241, 0.1);
    border: 1px solid rgba(99, 102, 241, 0.2);
    border-radius: var(--radius-sm);
    margin-top: 12px;
}

.trace-status-title {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 4px;
}

.trace-status-info {
    font-size: 11px;
    color: var(--text-dim);
}
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                        <path d="M2 17l10 5 10-5"/>
                        <path d="M2 12l10 5 10-5"/>
                    </svg>
                </div>
                SVG Studio Pro
            </div>
            
            <div class="mode-tabs">
                <button class="mode-tab active" data-mode="create">Create</button>
                <button class="mode-tab" data-mode="trace">Trace Image</button>
                <button class="mode-tab" data-mode="edit">Edit</button>
            </div>

            <div class="header-actions">
                <button class="btn btn-icon" id="undoBtn" title="Undo (Ctrl+Z)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                </button>
                <button class="btn btn-icon" id="redoBtn" title="Redo (Ctrl+Shift+Z)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"/>
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/>
                    </svg>
                </button>
                <div style="width: 1px; height: 24px; background: var(--border); margin: 0 4px;"></div>
                <button class="btn" id="newBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    New
                </button>
                <button class="btn" id="importBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Import
                </button>
                <button class="btn btn-primary" id="exportBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    Export
                </button>
                <div style="width: 1px; height: 24px; background: var(--border); margin: 0 4px;"></div>
                <button class="btn btn-icon" id="helpBtn" title="Keyboard Shortcuts (?)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Left Panel -->
        <aside class="left-panel" id="leftPanel">
            <!-- Create Mode Content -->
            <div class="create-mode-content">
                <div class="panel-section">
                    <div class="section-title">Tools</div>
                    <div class="tools-grid">
                        <button class="tool-btn active" data-tool="select" title="Select (V)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="pen" title="Pen (P)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="rectangle" title="Rectangle (R)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="ellipse" title="Ellipse (E)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <ellipse cx="12" cy="12" rx="10" ry="8"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="polygon" title="Polygon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="star" title="Star">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="line" title="Line (L)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="5" y1="19" x2="19" y2="5"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="text" title="Text (T)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="4 7 4 4 20 4 20 7"/>
                                <line x1="9" y1="20" x2="15" y2="20"/>
                                <line x1="12" y1="4" x2="12" y2="20"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="eyedropper" title="Eyedropper (I)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M2 22l1-1h3l9-9"/>
                                <path d="M3 21v-3l9-9"/>
                                <path d="M14.5 5.5L18.5 9.5"/>
                                <path d="M17.5 2.5a2.121 2.121 0 0 1 3 3L19 7l-4-4 1.5-1.5z"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="hand" title="Hand (H)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/>
                                <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/>
                                <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/>
                                <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                            </svg>
                        </button>
                        <button class="tool-btn" data-tool="zoom" title="Zoom (Z)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                                <line x1="11" y1="8" x2="11" y2="14"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="panel-section layers-section">
                    <div class="section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        Layers
                        <button class="btn btn-sm" id="addLayerBtn">+ Add</button>
                    </div>
                    <div class="layers-list" id="layersList"></div>
                </div>
            </div>

            <!-- Trace Mode Content -->
            <div class="trace-mode-content hidden">
                <div class="trace-panel">
                    <div id="dropZone" class="drop-zone">
                        <svg class="drop-zone-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <path d="M21 15l-5-5L5 21"/>
                        </svg>
                        <div class="drop-zone-text">Drop image here</div>
                        <div class="drop-zone-hint">or click to browse</div>
                    </div>
                    <input type="file" id="imageInput" accept="image/*" style="display: none;">

                    <div id="imagePreviewContainer" class="image-preview-container hidden">
                        <img id="imagePreview" class="image-preview" src="" alt="Preview">
                        <button class="btn btn-sm remove-image-btn" id="removeImageBtn">✕ Remove</button>
                    </div>

                    <div id="traceControls" class="trace-controls hidden">
                        <div class="control-group">
                            <div class="section-title">Quality Preset</div>
                            <div class="select-wrap">
                                <select id="traceQuality">
                                    <option value="fast">Fast</option>
                                    <option value="balanced" selected>Balanced</option>
                                    <option value="high">High Quality</option>
                                </select>
                                <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"/>
                                </svg>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="section-title">Mode</div>
                            <div class="select-wrap">
                                <select id="traceMode">
                                    <option value="bw">Black & White</option>
                                    <option value="color">Color (Palette)</option>
                                    <option value="grayscale">Grayscale</option>
                                </select>
                                <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"/>
                                </svg>
                            </div>
                        </div>

                        <div class="control-group" id="thresholdGroup">
                            <div class="control-label">
                                <span class="control-label-text">Threshold</span>
                                <span class="control-value" id="thresholdValue">128</span>
                            </div>
                            <input type="range" id="threshold" min="0" max="255" value="128">
                        </div>

                        <div class="control-group" id="colorCountGroup" style="display: none;">
                            <div class="control-label">
                                <span class="control-label-text">Colors Detected</span>
                                <span class="control-value" id="detectedColorsValue">--</span>
                            </div>
                            <div class="control-label" style="margin-top: 8px;">
                                <span class="control-label-text">Extract Colors</span>
                                <span class="control-value" id="colorCountValue">8</span>
                            </div>
                            <input type="range" id="colorCount" min="2" max="256" value="8">
                            <button class="btn btn-sm" id="autoColorBtn" style="margin-top: 8px; width: 100%;">
                                Auto-detect Colors
                            </button>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span class="control-label-text">Detail Level</span>
                                <span class="control-value" id="detailLevelValue">Medium</span>
                            </div>
                            <input type="range" id="detailLevel" min="1" max="5" value="3">
                        </div>

                        <div class="control-group advanced-settings hidden" id="advancedSettings">
                            <div class="section-title" style="font-size: 11px; margin-bottom: 8px;">Advanced</div>
                            <div class="control-label">
                                <span class="control-label-text">Path Tolerance</span>
                                <span class="control-value" id="toleranceValue">2</span>
                            </div>
                            <input type="range" id="tolerance" min="0.1" max="10" step="0.1" value="2">

                            <div class="control-label" style="margin-top: 8px;">
                                <span class="control-label-text">Minimum Area</span>
                                <span class="control-value" id="minAreaValue">4</span>
                            </div>
                            <input type="range" id="minArea" min="1" max="100" value="4">

                            <div class="control-label" style="margin-top: 8px;">
                                <span class="control-label-text">Corner Threshold</span>
                                <span class="control-value" id="cornerValue">60</span>
                            </div>
                            <input type="range" id="cornerThreshold" min="0" max="180" value="60">
                        </div>

                        <button class="btn btn-sm btn-text" id="toggleAdvanced" style="width: 100%; margin-top: 8px;">
                            Show Advanced Settings
                        </button>

                        <div class="toggle-row">
                            <span class="toggle-label">Smooth Curves</span>
                            <div class="toggle active" id="smoothToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>

                        <div class="toggle-row">
                            <span class="toggle-label">Invert Colors</span>
                            <div class="toggle" id="invertToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>

                        <div class="toggle-row">
                            <span class="toggle-label">Remove Background</span>
                            <div class="toggle" id="removeBgToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>

                        <button class="btn btn-primary" id="traceBtn" style="width: 100%; margin-top: 16px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"/>
                            </svg>
                            Trace Image
                        </button>

                        <div id="traceProgress" class="progress-container hidden">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                            </div>
                            <div class="progress-text" id="progressText">Processing...</div>
                        </div>

                        <div id="paletteContainer" class="hidden" style="margin-top: 16px;">
                            <div class="section-title">Extracted Palette</div>
                            <div class="palette-display" id="paletteDisplay"></div>
                        </div>

                        <div id="traceStatus" class="trace-status hidden">
                            <div class="trace-status-title">Trace Complete</div>
                            <div class="trace-status-info" id="traceStatusInfo">0 paths generated</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Edit Mode Content -->
            <div class="edit-mode-content hidden">
                <div class="left-panel-scroll">
                    <div class="left-panel-header">
                        <span class="panel-title">Edit Tools</span>
                    </div>

                    <div class="edit-mode-hint" id="editModeHint">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 8px; opacity: 0.6;">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4"/>
                            <path d="M12 8h.01"/>
                        </svg>
                        <p>Select a <strong>Path</strong> or <strong>Polygon</strong> to edit its nodes.</p>
                        <p style="font-size: 11px; opacity: 0.7; margin-top: 6px;">Use Create mode to draw shapes, then switch to Edit mode.</p>
                    </div>

                    <div class="tool-group" id="editToolsGroup">
                        <div class="section-title">Node Tools</div>
                        <div class="tool-grid">
                            <button class="tool-btn active" data-edit-tool="node-select" title="Select Node (V)">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M5 5l14 6-6 2-2 6z"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-edit-tool="add-node" title="Add Node (+)">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="8"/>
                                    <line x1="12" y1="8" x2="12" y2="16"/>
                                    <line x1="8" y1="12" x2="16" y2="12"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-edit-tool="delete-node" title="Delete Node (-)">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="8"/>
                                    <line x1="8" y1="12" x2="16" y2="12"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-edit-tool="convert-point" title="Convert Point">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="4" y="4" width="6" height="6" rx="1"/>
                                    <circle cx="17" cy="17" r="4"/>
                                    <path d="M10 7L14 14"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="tool-group">
                        <div class="section-title">Brush Tools</div>
                        <div class="tool-grid">
                            <button class="tool-btn" data-edit-tool="smooth-brush" title="Smooth Brush">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 17C6 14 10 14 12 12C14 10 18 10 21 7"/>
                                    <circle cx="12" cy="12" r="6" stroke-dasharray="2 2"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-edit-tool="expand-brush" title="Expand Brush">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="6"/>
                                    <path d="M12 6V2M12 22v-4M6 12H2M22 12h-4"/>
                                </svg>
                            </button>
                            <button class="tool-btn" data-edit-tool="shrink-brush" title="Shrink Brush">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="6"/>
                                    <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="tool-group" id="brushSettingsGroup">
                        <div class="section-title">Brush Settings</div>
                        <div class="control-group">
                            <div class="control-label">
                                <span class="control-label-text">Radius</span>
                                <span class="control-value" id="brushRadiusValue">30</span>
                            </div>
                            <input type="range" id="brushRadius" min="10" max="200" value="30">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                <span class="control-label-text">Strength</span>
                                <span class="control-value" id="brushStrengthValue">50%</span>
                            </div>
                            <input type="range" id="brushStrength" min="1" max="100" value="50">
                        </div>
                        <div class="control-group">
                            <div class="section-title" style="font-size: 11px;">Falloff</div>
                            <div class="select-wrap">
                                <select id="brushFalloff">
                                    <option value="linear">Linear</option>
                                    <option value="soft" selected>Soft</option>
                                    <option value="hard">Hard</option>
                                </select>
                                <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"/>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <div class="tool-group">
                        <div class="section-title">Node Properties</div>
                        <div class="prop-row" id="nodeTypeProp">
                            <span class="prop-label">Type</span>
                            <div class="select-wrap" style="flex: 1;">
                                <select id="nodeType">
                                    <option value="corner">Corner</option>
                                    <option value="smooth">Smooth</option>
                                    <option value="symmetric">Symmetric</option>
                                </select>
                                <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"/>
                                </svg>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">X</span>
                            <input type="number" class="prop-input prop-input-sm" id="nodeX" value="0">
                            <span class="prop-label">Y</span>
                            <input type="number" class="prop-input prop-input-sm" id="nodeY" value="0">
                        </div>
                    </div>

                    <div class="tool-group">
                        <div class="section-title">Path Operations</div>
                        <div class="btn-group-vertical">
                            <button class="btn btn-sm" id="closePathBtn">Close Path</button>
                            <button class="btn btn-sm" id="reversePathBtn">Reverse Path</button>
                            <button class="btn btn-sm" id="simplifyPathBtn">Simplify</button>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="canvas-area" id="canvasArea">
            <!-- Rulers -->
            <div class="ruler-corner"></div>
            <canvas class="ruler ruler-h" id="rulerH" height="20"></canvas>
            <canvas class="ruler ruler-v" id="rulerV" width="20"></canvas>

            <!-- Alignment Toolbar (shows when elements selected) -->
            <div class="align-toolbar" id="alignToolbar">
                <button class="align-btn" data-align="left" title="Align Left">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="4" x2="4" y2="20"/>
                        <rect x="8" y="6" width="12" height="4"/>
                        <rect x="8" y="14" width="8" height="4"/>
                    </svg>
                </button>
                <button class="align-btn" data-align="centerH" title="Align Center Horizontally">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="2" x2="12" y2="22"/>
                        <rect x="4" y="6" width="16" height="4"/>
                        <rect x="6" y="14" width="12" height="4"/>
                    </svg>
                </button>
                <button class="align-btn" data-align="right" title="Align Right">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="20" y1="4" x2="20" y2="20"/>
                        <rect x="4" y="6" width="12" height="4"/>
                        <rect x="8" y="14" width="8" height="4"/>
                    </svg>
                </button>
                <div class="divider"></div>
                <button class="align-btn" data-align="top" title="Align Top">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="4" x2="20" y2="4"/>
                        <rect x="6" y="8" width="4" height="12"/>
                        <rect x="14" y="8" width="4" height="8"/>
                    </svg>
                </button>
                <button class="align-btn" data-align="centerV" title="Align Center Vertically">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="2" y1="12" x2="22" y2="12"/>
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="6" width="4" height="12"/>
                    </svg>
                </button>
                <button class="align-btn" data-align="bottom" title="Align Bottom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="20" x2="20" y2="20"/>
                        <rect x="6" y="4" width="4" height="12"/>
                        <rect x="14" y="8" width="4" height="8"/>
                    </svg>
                </button>
                <div class="divider"></div>
                <button class="align-btn" data-align="distributeH" title="Distribute Horizontally">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="4" y="8" width="4" height="8"/>
                        <rect x="10" y="8" width="4" height="8"/>
                        <rect x="16" y="8" width="4" height="8"/>
                    </svg>
                </button>
                <button class="align-btn" data-align="distributeV" title="Distribute Vertically">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="8" y="4" width="8" height="4"/>
                        <rect x="8" y="10" width="8" height="4"/>
                        <rect x="8" y="16" width="8" height="4"/>
                    </svg>
                </button>
                <div class="divider"></div>
                <button class="align-btn" data-action="flipH" title="Flip Horizontal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 3v18"/>
                        <path d="M16 7l4 5-4 5"/>
                        <path d="M8 7l-4 5 4 5"/>
                    </svg>
                </button>
                <button class="align-btn" data-action="flipV" title="Flip Vertical">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12h18"/>
                        <path d="M7 8l5-4 5 4"/>
                        <path d="M7 16l5 4 5-4"/>
                    </svg>
                </button>
            </div>

            <div class="canvas-container" id="canvasContainer" style="position: absolute; left: 20px; top: 20px; right: 0; bottom: 0;">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas" width="800" height="600"></canvas>
                    <canvas id="selectionCanvas" width="800" height="600"></canvas>
                </div>
            </div>

            <div class="zoom-controls">
                <span class="cursor-coords" id="cursorCoords">X: 0 Y: 0</span>
                <div class="divider" style="width: 1px; height: 16px; background: var(--border); margin: 0 8px;"></div>
                <button class="btn btn-icon" id="zoomOutBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                        <line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="btn btn-icon" id="zoomInBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                        <line x1="11" y1="8" x2="11" y2="14"/>
                        <line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="btn btn-sm" id="fitBtn">Fit</button>
                <button class="btn btn-sm" id="resetZoomBtn">100%</button>
            </div>
        </main>

        <!-- Right Panel -->
        <aside class="right-panel">
            <div class="right-panel-tabs">
                <button class="panel-tab active" data-tab="properties">Properties</button>
                <button class="panel-tab" data-tab="fill">Fill</button>
                <button class="panel-tab" data-tab="stroke">Stroke</button>
                <button class="panel-tab" data-tab="code">Code</button>
            </div>

            <div class="right-panel-content">
                <!-- Properties Tab -->
                <div class="tab-content active" data-tab="properties">
                    <div class="properties-section">
                        <div class="section-title">Position</div>
                        <div class="prop-row">
                            <span class="prop-label">X</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propXSlider" min="-500" max="1500" value="0">
                                <input type="number" class="prop-input" id="propX" value="0">
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">Y</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propYSlider" min="-500" max="1500" value="0">
                                <input type="number" class="prop-input" id="propY" value="0">
                            </div>
                        </div>
                    </div>

                    <div class="properties-section">
                        <div class="section-title">Size</div>
                        <div class="prop-row">
                            <span class="prop-label">W</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propWSlider" min="1" max="1000" value="100">
                                <input type="number" class="prop-input" id="propW" value="100" min="1">
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">H</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propHSlider" min="1" max="1000" value="100">
                                <input type="number" class="prop-input" id="propH" value="100" min="1">
                            </div>
                        </div>
                    </div>

                    <div class="properties-section">
                        <div class="section-title">Transform</div>
                        <div class="prop-row">
                            <span class="prop-label">Rotate</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propRotationSlider" min="-180" max="180" value="0">
                                <input type="number" class="prop-input" id="propRotation" value="0">
                                <span class="prop-label">°</span>
                            </div>
                        </div>
                    </div>

                    <div class="properties-section">
                        <div class="section-title">Appearance</div>
                        <div class="prop-row">
                            <span class="prop-label">Opacity</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propOpacity" min="0" max="100" value="100">
                                <span class="control-value" id="opacityValue">100%</span>
                            </div>
                        </div>
                    </div>

                    <div class="properties-section" id="shapePropsSection">
                        <div class="section-title">Shape</div>
                        <div class="prop-row" id="cornerRadiusProp">
                            <span class="prop-label">Radius</span>
                            <div class="prop-slider-combo">
                                <input type="range" id="propCornerRadiusSlider" min="0" max="100" value="0">
                                <input type="number" class="prop-input" id="propCornerRadius" value="0" min="0">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Fill Tab -->
                <div class="tab-content" data-tab="fill">
                    <div class="properties-section">
                        <div class="section-title">Fill Type</div>
                        <div class="select-wrap">
                            <select id="fillType">
                                <option value="solid">Solid Color</option>
                                <option value="linear">Linear Gradient</option>
                                <option value="radial">Radial Gradient</option>
                                <option value="none">No Fill</option>
                            </select>
                            <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </div>
                    </div>

                    <div class="properties-section" id="solidFillSection">
                        <div class="section-title">Color</div>
                        <div class="color-picker-wrap">
                            <div class="color-swatch" id="fillColorSwatch">
                                <div class="color-swatch-inner" id="fillSwatchInner" style="background: #6366f1;"></div>
                                <input type="color" id="fillColorPicker" value="#6366f1" class="color-swatch-input">
                            </div>
                            <input type="text" class="prop-input color-hex" id="fillColorHex" value="#6366f1">
                        </div>
                        <div class="prop-row" style="margin-top: 12px;">
                            <span class="prop-label">Alpha</span>
                            <input type="range" id="fillAlpha" min="0" max="100" value="100" style="flex: 1;">
                            <span class="control-value" id="fillAlphaValue">100%</span>
                        </div>
                        <div class="section-title" style="margin-top: 12px;">Presets</div>
                        <div class="color-presets" id="fillColorPresets">
                            <div class="color-preset" data-color="#ef4444" style="background: #ef4444;" title="Red"></div>
                            <div class="color-preset" data-color="#f97316" style="background: #f97316;" title="Orange"></div>
                            <div class="color-preset" data-color="#eab308" style="background: #eab308;" title="Yellow"></div>
                            <div class="color-preset" data-color="#22c55e" style="background: #22c55e;" title="Green"></div>
                            <div class="color-preset" data-color="#06b6d4" style="background: #06b6d4;" title="Cyan"></div>
                            <div class="color-preset" data-color="#3b82f6" style="background: #3b82f6;" title="Blue"></div>
                            <div class="color-preset" data-color="#6366f1" style="background: #6366f1;" title="Indigo"></div>
                            <div class="color-preset" data-color="#a855f7" style="background: #a855f7;" title="Purple"></div>
                            <div class="color-preset" data-color="#ec4899" style="background: #ec4899;" title="Pink"></div>
                            <div class="color-preset" data-color="#ffffff" style="background: #ffffff; border: 1px solid var(--border);" title="White"></div>
                            <div class="color-preset" data-color="#71717a" style="background: #71717a;" title="Gray"></div>
                            <div class="color-preset" data-color="#000000" style="background: #000000;" title="Black"></div>
                        </div>
                    </div>

                    <div class="properties-section hidden" id="gradientFillSection">
                        <div class="section-title">Gradient</div>
                        <div class="gradient-preview" id="gradientPreview">
                            <div class="gradient-stops" id="gradientStops"></div>
                        </div>
                        
                        <div class="prop-row" id="gradientAngleRow">
                            <span class="prop-label">Angle</span>
                            <input type="number" class="prop-input" id="gradientAngle" value="0" min="0" max="360">
                            <span class="prop-label">°</span>
                        </div>

                        <div class="section-title" style="margin-top: 16px;">Stops</div>
                        <div id="gradientStopsList"></div>
                        <button class="btn btn-sm" id="addGradientStop" style="margin-top: 8px;">+ Add Stop</button>
                    </div>
                </div>

                <!-- Stroke Tab -->
                <div class="tab-content" data-tab="stroke">
                    <div class="properties-section">
                        <div class="toggle-row">
                            <span class="toggle-label">Enable Stroke</span>
                            <div class="toggle active" id="strokeToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>
                    </div>

                    <div class="properties-section" id="strokeSettings">
                        <div class="section-title">Color</div>
                        <div class="color-picker-wrap">
                            <div class="color-swatch" id="strokeColorSwatch">
                                <div class="color-swatch-inner" id="strokeSwatchInner" style="background: #000000;"></div>
                                <input type="color" id="strokeColorPicker" value="#000000" class="color-swatch-input">
                            </div>
                            <input type="text" class="prop-input color-hex" id="strokeColorHex" value="#000000">
                        </div>

                        <div class="section-title" style="margin-top: 16px;">Width</div>
                        <div class="prop-row">
                            <input type="number" class="prop-input" id="strokeWidth" value="2" min="0" step="0.5">
                            <span class="prop-label">px</span>
                        </div>

                        <div class="section-title" style="margin-top: 16px;">Style</div>
                        <div class="select-wrap">
                            <select id="strokeStyle">
                                <option value="solid">Solid</option>
                                <option value="dashed">Dashed</option>
                                <option value="dotted">Dotted</option>
                            </select>
                            <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </div>

                        <div class="section-title" style="margin-top: 16px;">Line Cap</div>
                        <div class="select-wrap">
                            <select id="strokeLinecap">
                                <option value="butt">Butt</option>
                                <option value="round">Round</option>
                                <option value="square">Square</option>
                            </select>
                            <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </div>

                        <div class="section-title" style="margin-top: 16px;">Line Join</div>
                        <div class="select-wrap">
                            <select id="strokeLinejoin">
                                <option value="miter">Miter</option>
                                <option value="round">Round</option>
                                <option value="bevel">Bevel</option>
                            </select>
                            <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </div>
                    </div>

                    <!-- Effects Section -->
                    <div class="properties-section" id="effectsSection">
                        <div class="section-title">Effects</div>

                        <!-- Drop Shadow -->
                        <div class="toggle-row">
                            <span class="toggle-label">Drop Shadow</span>
                            <div class="toggle" id="shadowToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>
                        <div id="shadowControls" class="hidden" style="margin-top: 12px;">
                            <div class="prop-row">
                                <span class="prop-label">X</span>
                                <input type="number" class="prop-input prop-input-sm" id="shadowX" value="4">
                                <span class="prop-label">Y</span>
                                <input type="number" class="prop-input prop-input-sm" id="shadowY" value="4">
                            </div>
                            <div class="prop-row" style="margin-top: 8px;">
                                <span class="prop-label">Blur</span>
                                <input type="number" class="prop-input prop-input-sm" id="shadowBlur" value="8" min="0">
                                <span class="prop-label">Opacity</span>
                                <input type="number" class="prop-input prop-input-sm" id="shadowOpacity" value="0.3" min="0" max="1" step="0.1">
                            </div>
                            <div class="color-picker-wrap" style="margin-top: 8px;">
                                <span class="prop-label">Color</span>
                                <div class="color-swatch" id="shadowColorSwatch" style="margin-left: 8px;">
                                    <div class="color-swatch-inner" id="shadowSwatchInner" style="background: #000000;"></div>
                                </div>
                                <input type="color" id="shadowColorPicker" value="#000000" style="display: none;">
                            </div>
                        </div>

                        <!-- Blur -->
                        <div class="toggle-row" style="margin-top: 16px;">
                            <span class="toggle-label">Blur</span>
                            <div class="toggle" id="blurToggle">
                                <div class="toggle-handle"></div>
                            </div>
                        </div>
                        <div id="blurControls" class="hidden" style="margin-top: 12px;">
                            <div class="prop-row">
                                <span class="prop-label">Amount</span>
                                <input type="range" id="blurAmount" min="0" max="20" value="5" step="0.5" style="flex: 1;">
                                <span class="control-value" id="blurValue">5px</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Code Tab -->
                <div class="tab-content" data-tab="code">
                    <div class="code-panel">
                        <div class="code-toolbar">
                            <span style="font-size: 12px; color: var(--text-dim);">SVG Code</span>
                            <div style="display: flex; gap: 4px;">
                                <button class="btn btn-sm" id="copyCodeBtn">Copy</button>
                                <button class="btn btn-sm" id="formatCodeBtn">Format</button>
                            </div>
                        </div>
                        <div class="code-editor" id="codeEditor" contenteditable="true" spellcheck="false"></div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Export</h3>
                <button class="modal-close" id="closeExportModal">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>

            <div class="export-options">
                <div class="export-option selected" data-format="svg">
                    <div class="export-option-icon">📐</div>
                    <div class="export-option-name">SVG</div>
                    <div class="export-option-desc">Scalable vector</div>
                </div>
                <div class="export-option" data-format="png">
                    <div class="export-option-icon">🖼️</div>
                    <div class="export-option-name">PNG</div>
                    <div class="export-option-desc">Raster image</div>
                </div>
                <div class="export-option" data-format="svg-optimized">
                    <div class="export-option-icon">⚡</div>
                    <div class="export-option-name">SVG (Optimized)</div>
                    <div class="export-option-desc">Minified code</div>
                </div>
                <div class="export-option" data-format="copy">
                    <div class="export-option-icon">📋</div>
                    <div class="export-option-name">Copy Code</div>
                    <div class="export-option-desc">To clipboard</div>
                </div>
            </div>

            <div class="properties-section" id="pngOptionsSection" style="display: none;">
                <div class="section-title">PNG Options</div>
                <div class="prop-row">
                    <span class="prop-label">Scale</span>
                    <div class="select-wrap" style="flex: 1;">
                        <select id="pngScale">
                            <option value="1">1x (Original)</option>
                            <option value="2" selected>2x (Retina)</option>
                            <option value="3">3x</option>
                            <option value="4">4x</option>
                        </select>
                        <svg class="select-arrow" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Transparent Background</span>
                    <div class="toggle active" id="pngTransparentToggle">
                        <div class="toggle-handle"></div>
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" id="doExportBtn" style="width: 100%;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                Download SVG
            </button>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-item" data-action="duplicate">Duplicate</div>
        <div class="context-item" data-action="delete">Delete</div>
        <div class="context-separator"></div>
        <div class="context-item" data-action="bringFront">Bring to Front</div>
        <div class="context-item" data-action="sendBack">Send to Back</div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="modal-title">Keyboard Shortcuts</h3>
                <button class="modal-close" id="closeHelpModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                <div class="shortcuts-section">
                    <h4 class="shortcuts-title">Tools</h4>
                    <div class="shortcut-row"><span class="shortcut-key">V</span><span>Select Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">P</span><span>Pen Tool (Freehand)</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">R</span><span>Rectangle Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">E</span><span>Ellipse Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">L</span><span>Line Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">T</span><span>Text Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">I</span><span>Eyedropper Tool</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">H</span><span>Hand Tool (Pan)</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Z</span><span>Zoom Tool</span></div>
                </div>
                <div class="shortcuts-section">
                    <h4 class="shortcuts-title">Edit</h4>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+Z</span><span>Undo</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+Shift+Z</span><span>Redo</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+C</span><span>Copy</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+V</span><span>Paste</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+D</span><span>Duplicate</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+A</span><span>Select All</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+G</span><span>Group Elements</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+Shift+G</span><span>Ungroup</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Delete</span><span>Delete Selection</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Escape</span><span>Deselect / Close Modal</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Arrow Keys</span><span>Nudge 1px</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Shift+Arrow</span><span>Nudge 10px</span></div>
                </div>
                <div class="shortcuts-section">
                    <h4 class="shortcuts-title">View</h4>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl++</span><span>Zoom In</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+-</span><span>Zoom Out</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+0</span><span>Reset Zoom (100%)</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Scroll</span><span>Zoom In/Out</span></div>
                    <div class="shortcut-row"><span class="shortcut-key">Middle Mouse</span><span>Pan Canvas</span></div>
                </div>
                <div class="shortcuts-section">
                    <h4 class="shortcuts-title">File</h4>
                    <div class="shortcut-row"><span class="shortcut-key">Ctrl+S</span><span>Export</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

<script>
// ===== SVG Studio Pro - Main Application =====

class SVGStudio {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.selectionCanvas = document.getElementById('selectionCanvas');
        this.selectionCtx = this.selectionCanvas.getContext('2d');
        
        this.elements = [];
        this.selectedElements = [];
        this.currentTool = 'select';
        this.zoom = 1;
        this.pan = { x: 0, y: 0 };
        this.isDrawing = false;
        this.isDragging = false;
        this.isPanning = false;
        this.drawStart = { x: 0, y: 0 };
        this.dragStart = { x: 0, y: 0 };
        this.clipboard = null;
        
        this.canvasWidth = 800;
        this.canvasHeight = 600;
        
        this.currentMode = 'create';
        this.traceImage = null;

        // Undo/Redo history
        this.history = [];
        this.historyIndex = -1;
        this.maxHistory = 50;

        // Pen tool state
        this.penPoints = [];
        this.isDrawingPen = false;

        // Text tool state
        this.activeTextInput = null;

        // Resize handle state
        this.isResizing = false;
        this.resizeHandle = null;
        this.resizeStart = { x: 0, y: 0, element: null };

        // Smart guides & snapping
        this.guides = { vertical: [], horizontal: [] };
        this.snapThreshold = 8;
        this.showSmartGuides = true;
        this.activeSmartGuides = [];

        // Rotation state
        this.isRotating = false;
        this.rotationStart = 0;

        // Default styles
        this.currentFill = { type: 'solid', color: '#6366f1', alpha: 1 };
        this.currentStroke = { enabled: true, color: '#000000', width: 2, style: 'solid', linecap: 'round', linejoin: 'round' };
        this.currentGradient = {
            type: 'linear',
            angle: 90,
            stops: [
                { offset: 0, color: '#6366f1' },
                { offset: 1, color: '#a855f7' }
            ]
        };
        
        this.init();
    }
    
    init() {
        this.loadFromLocalStorage();
        this.setupEventListeners();
        this.setupAlignmentToolbar();
        this.initRulers();
        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.saveToHistory();

        // Auto-save every 30 seconds
        setInterval(() => this.saveToLocalStorage(), 30000);
    }

    // ==================== RULERS ====================

    initRulers() {
        this.rulerH = document.getElementById('rulerH');
        this.rulerV = document.getElementById('rulerV');
        this.rulerHCtx = this.rulerH.getContext('2d');
        this.rulerVCtx = this.rulerV.getContext('2d');
        this.updateRulers();
    }

    updateRulers() {
        if (!this.rulerH) return;

        const container = document.getElementById('canvasContainer');
        if (!container) return;

        // Resize ruler canvases
        this.rulerH.width = container.offsetWidth;
        this.rulerV.height = container.offsetHeight;

        // Draw horizontal ruler
        this.rulerHCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-panel');
        this.rulerHCtx.fillRect(0, 0, this.rulerH.width, 20);

        this.rulerHCtx.strokeStyle = '#444';
        this.rulerHCtx.fillStyle = '#888';
        this.rulerHCtx.font = '9px sans-serif';
        this.rulerHCtx.textAlign = 'center';

        const step = this.zoom >= 2 ? 10 : this.zoom >= 1 ? 20 : this.zoom >= 0.5 ? 50 : 100;
        for (let x = 0; x < this.canvasWidth; x += step) {
            const screenX = x * this.zoom + this.pan.x * this.zoom;
            if (screenX >= 0 && screenX <= this.rulerH.width) {
                this.rulerHCtx.beginPath();
                this.rulerHCtx.moveTo(screenX, x % (step * 5) === 0 ? 8 : 14);
                this.rulerHCtx.lineTo(screenX, 20);
                this.rulerHCtx.stroke();
                if (x % (step * 5) === 0) {
                    this.rulerHCtx.fillText(x.toString(), screenX, 8);
                }
            }
        }

        // Draw vertical ruler
        this.rulerVCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-panel');
        this.rulerVCtx.fillRect(0, 0, 20, this.rulerV.height);

        this.rulerVCtx.strokeStyle = '#444';
        this.rulerVCtx.fillStyle = '#888';
        this.rulerVCtx.font = '9px sans-serif';
        this.rulerVCtx.textAlign = 'right';

        for (let y = 0; y < this.canvasHeight; y += step) {
            const screenY = y * this.zoom + this.pan.y * this.zoom;
            if (screenY >= 0 && screenY <= this.rulerV.height) {
                this.rulerVCtx.beginPath();
                this.rulerVCtx.moveTo(y % (step * 5) === 0 ? 8 : 14, screenY);
                this.rulerVCtx.lineTo(20, screenY);
                this.rulerVCtx.stroke();
                if (y % (step * 5) === 0) {
                    this.rulerVCtx.save();
                    this.rulerVCtx.translate(8, screenY);
                    this.rulerVCtx.rotate(-Math.PI / 2);
                    this.rulerVCtx.textAlign = 'center';
                    this.rulerVCtx.fillText(y.toString(), 0, 0);
                    this.rulerVCtx.restore();
                }
            }
        }
    }

    // ==================== ALIGNMENT TOOLBAR ====================

    setupAlignmentToolbar() {
        // Alignment buttons
        document.querySelectorAll('.align-btn[data-align]').forEach(btn => {
            btn.addEventListener('click', () => this.alignElements(btn.dataset.align));
        });

        // Flip buttons
        document.querySelectorAll('.align-btn[data-action]').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.dataset.action === 'flipH') this.flipElements('horizontal');
                if (btn.dataset.action === 'flipV') this.flipElements('vertical');
            });
        });
    }

    updateAlignToolbar() {
        const toolbar = document.getElementById('alignToolbar');
        toolbar.classList.toggle('visible', this.selectedElements.length > 0);
    }

    alignElements(alignment) {
        if (this.selectedElements.length === 0) return;

        const bboxes = this.selectedElements.map(el => this.getElementBBox(el));

        // Get bounds of all selected elements
        const minX = Math.min(...bboxes.map(b => b.x));
        const maxX = Math.max(...bboxes.map(b => b.x + b.width));
        const minY = Math.min(...bboxes.map(b => b.y));
        const maxY = Math.max(...bboxes.map(b => b.y + b.height));
        const totalWidth = maxX - minX;
        const totalHeight = maxY - minY;
        const centerX = minX + totalWidth / 2;
        const centerY = minY + totalHeight / 2;

        this.selectedElements.forEach((el, i) => {
            const bbox = bboxes[i];
            let dx = 0, dy = 0;

            switch (alignment) {
                case 'left':
                    dx = minX - bbox.x;
                    break;
                case 'centerH':
                    dx = centerX - (bbox.x + bbox.width / 2);
                    break;
                case 'right':
                    dx = maxX - (bbox.x + bbox.width);
                    break;
                case 'top':
                    dy = minY - bbox.y;
                    break;
                case 'centerV':
                    dy = centerY - (bbox.y + bbox.height / 2);
                    break;
                case 'bottom':
                    dy = maxY - (bbox.y + bbox.height);
                    break;
            }

            this.moveElement(el, dx, dy);
        });

        // Distribute
        if (alignment === 'distributeH' && this.selectedElements.length >= 3) {
            const sorted = [...this.selectedElements].sort((a, b) => {
                const ba = this.getElementBBox(a);
                const bb = this.getElementBBox(b);
                return ba.x - bb.x;
            });
            const firstBbox = this.getElementBBox(sorted[0]);
            const lastBbox = this.getElementBBox(sorted[sorted.length - 1]);
            const totalSpace = (lastBbox.x + lastBbox.width) - firstBbox.x;
            const elemWidth = sorted.reduce((sum, el) => sum + this.getElementBBox(el).width, 0);
            const gap = (totalSpace - elemWidth) / (sorted.length - 1);

            let currentX = firstBbox.x + firstBbox.width + gap;
            for (let i = 1; i < sorted.length - 1; i++) {
                const bbox = this.getElementBBox(sorted[i]);
                this.moveElement(sorted[i], currentX - bbox.x, 0);
                currentX += bbox.width + gap;
            }
        }

        if (alignment === 'distributeV' && this.selectedElements.length >= 3) {
            const sorted = [...this.selectedElements].sort((a, b) => {
                const ba = this.getElementBBox(a);
                const bb = this.getElementBBox(b);
                return ba.y - bb.y;
            });
            const firstBbox = this.getElementBBox(sorted[0]);
            const lastBbox = this.getElementBBox(sorted[sorted.length - 1]);
            const totalSpace = (lastBbox.y + lastBbox.height) - firstBbox.y;
            const elemHeight = sorted.reduce((sum, el) => sum + this.getElementBBox(el).height, 0);
            const gap = (totalSpace - elemHeight) / (sorted.length - 1);

            let currentY = firstBbox.y + firstBbox.height + gap;
            for (let i = 1; i < sorted.length - 1; i++) {
                const bbox = this.getElementBBox(sorted[i]);
                this.moveElement(sorted[i], 0, currentY - bbox.y);
                currentY += bbox.height + gap;
            }
        }

        this.render();
        this.updatePropertiesPanel();
        this.saveToHistory();
        this.saveToLocalStorage();
    }

    moveElement(el, dx, dy) {
        if (el.type === 'group' && el.children) {
            el.children.forEach(child => this.moveElement(child, dx, dy));
            return;
        }
        if (el.x !== undefined) el.x += dx;
        if (el.y !== undefined) el.y += dy;
        if (el.cx !== undefined) el.cx += dx;
        if (el.cy !== undefined) el.cy += dy;
        if (el.x1 !== undefined) { el.x1 += dx; el.x2 += dx; }
        if (el.y1 !== undefined) { el.y1 += dy; el.y2 += dy; }
        if (el.points) {
            el.points = el.points.split(' ').map(p => {
                const [x, y] = p.split(',').map(Number);
                return `${x + dx},${y + dy}`;
            }).join(' ');
        }
        if (el.d) {
            // Move SVG path by translating coordinates
            el.d = this.translatePath(el.d, dx, dy);
        }
    }

    translatePath(d, dx, dy) {
        // Handle common SVG path commands by adjusting coordinates
        return d.replace(/([MLHVCSQTAZ])([^MLHVCSQTAZ]*)/gi, (match, cmd, coords) => {
            const upperCmd = cmd.toUpperCase();
            const isRelative = cmd !== upperCmd;

            if (isRelative) return match; // Relative commands don't need translation

            const nums = coords.trim().split(/[\s,]+/).map(Number).filter(n => !isNaN(n));

            switch (upperCmd) {
                case 'M':
                case 'L':
                case 'T':
                    for (let i = 0; i < nums.length; i += 2) {
                        nums[i] += dx;
                        if (nums[i + 1] !== undefined) nums[i + 1] += dy;
                    }
                    break;
                case 'H':
                    for (let i = 0; i < nums.length; i++) nums[i] += dx;
                    break;
                case 'V':
                    for (let i = 0; i < nums.length; i++) nums[i] += dy;
                    break;
                case 'C':
                    for (let i = 0; i < nums.length; i += 6) {
                        nums[i] += dx; nums[i + 1] += dy;
                        nums[i + 2] += dx; nums[i + 3] += dy;
                        nums[i + 4] += dx; nums[i + 5] += dy;
                    }
                    break;
                case 'S':
                case 'Q':
                    for (let i = 0; i < nums.length; i += 4) {
                        nums[i] += dx; nums[i + 1] += dy;
                        nums[i + 2] += dx; nums[i + 3] += dy;
                    }
                    break;
                case 'A':
                    for (let i = 0; i < nums.length; i += 7) {
                        nums[i + 5] += dx;
                        nums[i + 6] += dy;
                    }
                    break;
                case 'Z':
                    return match;
            }
            return cmd + nums.join(' ');
        });
    }

    flipElements(direction) {
        if (this.selectedElements.length === 0) return;

        const bboxes = this.selectedElements.map(el => this.getElementBBox(el));
        const minX = Math.min(...bboxes.map(b => b.x));
        const maxX = Math.max(...bboxes.map(b => b.x + b.width));
        const minY = Math.min(...bboxes.map(b => b.y));
        const maxY = Math.max(...bboxes.map(b => b.y + b.height));
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        this.selectedElements.forEach((el, i) => {
            const bbox = bboxes[i];

            if (direction === 'horizontal') {
                const elCenterX = bbox.x + bbox.width / 2;
                const newCenterX = centerX + (centerX - elCenterX);
                const dx = newCenterX - elCenterX;

                if (el.x !== undefined) el.x = newCenterX - bbox.width / 2;
                if (el.cx !== undefined) el.cx += dx;
                if (el.x1 !== undefined) {
                    const mx = (el.x1 + el.x2) / 2;
                    el.x1 = centerX + (centerX - el.x1);
                    el.x2 = centerX + (centerX - el.x2);
                }
            } else {
                const elCenterY = bbox.y + bbox.height / 2;
                const newCenterY = centerY + (centerY - elCenterY);
                const dy = newCenterY - elCenterY;

                if (el.y !== undefined) el.y = newCenterY - bbox.height / 2;
                if (el.cy !== undefined) el.cy += dy;
                if (el.y1 !== undefined) {
                    el.y1 = centerY + (centerY - el.y1);
                    el.y2 = centerY + (centerY - el.y2);
                }
            }
        });

        this.render();
        this.updatePropertiesPanel();
        this.saveToHistory();
        this.saveToLocalStorage();
        this.showToast(`Flipped ${direction}`, 'success');
    }

    // ==================== SMART GUIDES & SNAPPING ====================

    calculateSmartGuides(dx, dy) {
        const SNAP_THRESHOLD = 8;
        const guides = [];
        let snapDx = dx, snapDy = dy;

        if (this.selectedElements.length === 0) {
            return { dx, dy, guides };
        }

        // Get current bounding box of selected elements
        const selectedBboxes = this.selectedElements.map(el => this.getElementBBox(el));
        const selMinX = Math.min(...selectedBboxes.map(b => b.x)) + dx;
        const selMaxX = Math.max(...selectedBboxes.map(b => b.x + b.width)) + dx;
        const selMinY = Math.min(...selectedBboxes.map(b => b.y)) + dy;
        const selMaxY = Math.max(...selectedBboxes.map(b => b.y + b.height)) + dy;
        const selCenterX = (selMinX + selMaxX) / 2;
        const selCenterY = (selMinY + selMaxY) / 2;

        // Canvas center guides
        const canvasCenterX = this.canvasWidth / 2;
        const canvasCenterY = this.canvasHeight / 2;

        // Collect snap targets from other elements
        const targets = {
            vertical: [0, canvasCenterX, this.canvasWidth],
            horizontal: [0, canvasCenterY, this.canvasHeight]
        };

        this.elements.forEach(el => {
            if (this.selectedElements.includes(el)) return;
            const bbox = this.getElementBBox(el);
            targets.vertical.push(bbox.x, bbox.x + bbox.width / 2, bbox.x + bbox.width);
            targets.horizontal.push(bbox.y, bbox.y + bbox.height / 2, bbox.y + bbox.height);
        });

        // Check for vertical snapping (left, center, right edges)
        let snappedX = false;
        const selEdgesX = [selMinX, selCenterX, selMaxX];
        for (const target of targets.vertical) {
            for (const edge of selEdgesX) {
                const diff = target - edge;
                if (Math.abs(diff) < SNAP_THRESHOLD && !snappedX) {
                    snapDx = dx + diff;
                    snappedX = true;
                    guides.push({ type: 'v', x: target });
                    break;
                }
            }
            if (snappedX) break;
        }

        // Check for horizontal snapping (top, center, bottom edges)
        let snappedY = false;
        const selEdgesY = [selMinY, selCenterY, selMaxY];
        for (const target of targets.horizontal) {
            for (const edge of selEdgesY) {
                const diff = target - edge;
                if (Math.abs(diff) < SNAP_THRESHOLD && !snappedY) {
                    snapDy = dy + diff;
                    snappedY = true;
                    guides.push({ type: 'h', y: target });
                    break;
                }
            }
            if (snappedY) break;
        }

        return { dx: snapDx, dy: snapDy, guides };
    }

    drawSmartGuides(guides) {
        if (!guides || guides.length === 0) {
            this.clearSmartGuides();
            return;
        }

        // Draw guides on selection canvas
        this.selectionCtx.save();
        this.selectionCtx.strokeStyle = '#ff00ff';
        this.selectionCtx.lineWidth = 1;
        this.selectionCtx.setLineDash([4, 4]);

        guides.forEach(guide => {
            this.selectionCtx.beginPath();
            if (guide.type === 'v') {
                this.selectionCtx.moveTo(guide.x, 0);
                this.selectionCtx.lineTo(guide.x, this.canvasHeight);
            } else if (guide.type === 'h') {
                this.selectionCtx.moveTo(0, guide.y);
                this.selectionCtx.lineTo(this.canvasWidth, guide.y);
            }
            this.selectionCtx.stroke();
        });

        this.selectionCtx.restore();
    }

    clearSmartGuides() {
        // Smart guides are drawn on selection canvas, cleared during normal render
    }

    // ==================== GROUPING ====================

    groupElements() {
        if (this.selectedElements.length < 2) return;

        // Create group element
        const group = {
            id: 'group_' + Date.now(),
            type: 'group',
            children: this.selectedElements.map(el => JSON.parse(JSON.stringify(el))),
            fill: 'none',
            stroke: 'none'
        };

        // Remove original elements
        this.selectedElements.forEach(el => {
            const idx = this.elements.indexOf(el);
            if (idx > -1) this.elements.splice(idx, 1);
        });

        // Add group
        this.elements.push(group);
        this.selectedElements = [group];

        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.saveToHistory();
        this.saveToLocalStorage();
        this.showToast('Elements grouped', 'success');
    }

    ungroupElements() {
        if (this.selectedElements.length !== 1) return;
        const group = this.selectedElements[0];
        if (group.type !== 'group') return;

        const idx = this.elements.indexOf(group);
        if (idx === -1) return;

        // Remove group and insert children
        this.elements.splice(idx, 1, ...group.children.map(c => {
            c.id = c.type + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            return c;
        }));

        this.selectedElements = [...group.children];

        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.saveToHistory();
        this.saveToLocalStorage();
        this.showToast('Group ungrouped', 'success');
    }

    // ==================== HISTORY (UNDO/REDO) ====================

    saveToHistory() {
        // Remove any future states if we're in the middle of history
        if (this.historyIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyIndex + 1);
        }

        // Add current state
        const state = JSON.stringify(this.elements);
        this.history.push(state);

        // Limit history size
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        } else {
            this.historyIndex++;
        }

        this.updateUndoRedoButtons();
    }

    undo() {
        if (this.historyIndex > 0) {
            this.historyIndex--;
            this.elements = JSON.parse(this.history[this.historyIndex]);
            this.selectedElements = [];
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.updatePropertiesPanel();
            this.updateUndoRedoButtons();
            this.showToast('Undo', 'success');
        }
    }

    redo() {
        if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.elements = JSON.parse(this.history[this.historyIndex]);
            this.selectedElements = [];
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.updatePropertiesPanel();
            this.updateUndoRedoButtons();
            this.showToast('Redo', 'success');
        }
    }

    updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        if (undoBtn) undoBtn.disabled = this.historyIndex <= 0;
        if (redoBtn) redoBtn.disabled = this.historyIndex >= this.history.length - 1;
    }

    // ==================== LOCAL STORAGE ====================

    saveToLocalStorage() {
        try {
            const data = {
                elements: this.elements,
                canvasWidth: this.canvasWidth,
                canvasHeight: this.canvasHeight,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem('svgStudioData', JSON.stringify(data));
        } catch (e) {
            console.warn('Could not save to localStorage:', e);
        }
    }

    loadFromLocalStorage() {
        try {
            const saved = localStorage.getItem('svgStudioData');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.elements && data.elements.length > 0) {
                    this.elements = data.elements;
                    this.canvasWidth = data.canvasWidth || 800;
                    this.canvasHeight = data.canvasHeight || 600;
                    this.canvas.width = this.canvasWidth;
                    this.canvas.height = this.canvasHeight;
                    this.selectionCanvas.width = this.canvasWidth;
                    this.selectionCanvas.height = this.canvasHeight;
                    this.showToast('Previous work restored', 'success');
                }
            }
        } catch (e) {
            console.warn('Could not load from localStorage:', e);
        }
    }

    clearLocalStorage() {
        localStorage.removeItem('svgStudioData');
    }
    
    setupEventListeners() {
        // Mode tabs
        document.querySelectorAll('.mode-tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchMode(tab.dataset.mode));
        });
        
        // Tool buttons
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => this.selectTool(btn.dataset.tool));
        });
        
        // Canvas events - use pointer events for pressure sensitivity
        this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
        this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
        this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));
        this.canvas.addEventListener('pointerleave', (e) => this.handlePointerUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));

        // Initialize pen settings
        this.penPressureEnabled = true;
        this.penMinWidth = 1;
        this.penMaxWidth = 10;
        this.penTaperStart = 0.2;
        this.penTaperEnd = 0.1;
        
        // Zoom controls
        document.getElementById('zoomInBtn').addEventListener('click', () => this.setZoom(this.zoom * 1.25));
        document.getElementById('zoomOutBtn').addEventListener('click', () => this.setZoom(this.zoom / 1.25));
        document.getElementById('fitBtn').addEventListener('click', () => this.fitToCanvas());
        document.getElementById('resetZoomBtn').addEventListener('click', () => this.setZoom(1));
        
        // Panel tabs
        document.querySelectorAll('.panel-tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchPanelTab(tab.dataset.tab));
        });
        
        // Property inputs
        this.setupPropertyInputs();
        this.setupFillStrokeControls();
        this.setupGradientControls();
        this.setupEffectsControls();

        // Export
        document.getElementById('exportBtn').addEventListener('click', () => this.showExportModal());
        document.getElementById('closeExportModal').addEventListener('click', () => this.hideExportModal());
        document.querySelectorAll('.export-option').forEach(opt => {
            opt.addEventListener('click', () => this.selectExportFormat(opt));
        });
        document.getElementById('doExportBtn').addEventListener('click', () => this.doExport());

        // Help modal
        document.getElementById('helpBtn').addEventListener('click', () => this.showHelpModal());
        document.getElementById('closeHelpModal').addEventListener('click', () => this.hideHelpModal());
        document.getElementById('helpModal').addEventListener('click', (e) => {
            if (e.target.id === 'helpModal') this.hideHelpModal();
        });
        
        // Undo/Redo
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());

        // Import & New
        document.getElementById('importBtn').addEventListener('click', () => this.importSVG());
        document.getElementById('newBtn').addEventListener('click', () => this.newDocument());
        document.getElementById('addLayerBtn').addEventListener('click', () => this.addNewShape());
        
        // Trace mode
        this.setupTraceMode();
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        
        // Code editor
        document.getElementById('copyCodeBtn').addEventListener('click', () => this.copyCode());
        document.getElementById('formatCodeBtn').addEventListener('click', () => this.formatCode());
        
        // Context menu
        document.addEventListener('click', () => this.hideContextMenu());
        document.querySelectorAll('.context-item').forEach(item => {
            item.addEventListener('click', () => this.handleContextAction(item.dataset.action));
        });
        
        // Modal
        document.getElementById('exportModal').addEventListener('click', (e) => {
            if (e.target.id === 'exportModal') this.hideExportModal();
        });
    }
    
    setupPropertyInputs() {
        // Slider-input pairs that sync together
        const sliderPairs = [
            { slider: 'propXSlider', input: 'propX' },
            { slider: 'propYSlider', input: 'propY' },
            { slider: 'propWSlider', input: 'propW' },
            { slider: 'propHSlider', input: 'propH' },
            { slider: 'propRotationSlider', input: 'propRotation' },
            { slider: 'propCornerRadiusSlider', input: 'propCornerRadius' }
        ];

        sliderPairs.forEach(({ slider, input }) => {
            const sliderEl = document.getElementById(slider);
            const inputEl = document.getElementById(input);

            if (sliderEl && inputEl) {
                // Slider updates input and applies
                sliderEl.addEventListener('input', () => {
                    inputEl.value = sliderEl.value;
                    this.updateSelectedFromProps();
                });

                // Input updates slider and applies
                inputEl.addEventListener('input', () => {
                    sliderEl.value = inputEl.value;
                });
                inputEl.addEventListener('change', () => {
                    sliderEl.value = inputEl.value;
                    this.updateSelectedFromProps();
                });
            }
        });

        document.getElementById('propOpacity').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value + '%';
            this.updateSelectedFromProps();
        });
    }
    
    setupFillStrokeControls() {
        // Fill type
        document.getElementById('fillType').addEventListener('change', (e) => {
            this.currentFill.type = e.target.value;
            this.updateFillUI();
            this.updateSelected();
        });
        
        // Fill color
        document.getElementById('fillColorPicker').addEventListener('input', (e) => {
            this.currentFill.color = e.target.value;
            document.getElementById('fillSwatchInner').style.background = e.target.value;
            document.getElementById('fillColorHex').value = e.target.value;
            this.updateSelected();
        });
        
        document.getElementById('fillColorHex').addEventListener('change', (e) => {
            if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                this.currentFill.color = e.target.value;
                document.getElementById('fillSwatchInner').style.background = e.target.value;
                document.getElementById('fillColorPicker').value = e.target.value;
                this.updateSelected();
            }
        });
        
        document.getElementById('fillAlpha').addEventListener('input', (e) => {
            this.currentFill.alpha = e.target.value / 100;
            document.getElementById('fillAlphaValue').textContent = e.target.value + '%';
            this.updateSelected();
        });

        // Fill color presets
        document.querySelectorAll('#fillColorPresets .color-preset').forEach(preset => {
            preset.addEventListener('click', () => {
                const color = preset.dataset.color;
                this.currentFill.color = color;
                document.getElementById('fillSwatchInner').style.background = color;
                document.getElementById('fillColorHex').value = color;
                document.getElementById('fillColorPicker').value = color;
                this.updateSelected();
            });
        });

        // Stroke toggle
        document.getElementById('strokeToggle').addEventListener('click', (e) => {
            const toggle = e.currentTarget;
            toggle.classList.toggle('active');
            this.currentStroke.enabled = toggle.classList.contains('active');
            this.updateSelected();
        });
        
        // Stroke color
        document.getElementById('strokeColorPicker').addEventListener('input', (e) => {
            this.currentStroke.color = e.target.value;
            document.getElementById('strokeSwatchInner').style.background = e.target.value;
            document.getElementById('strokeColorHex').value = e.target.value;
            this.updateSelected();
        });
        
        document.getElementById('strokeColorHex').addEventListener('change', (e) => {
            if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                this.currentStroke.color = e.target.value;
                document.getElementById('strokeSwatchInner').style.background = e.target.value;
                document.getElementById('strokeColorPicker').value = e.target.value;
                this.updateSelected();
            }
        });
        
        document.getElementById('strokeWidth').addEventListener('change', (e) => {
            this.currentStroke.width = parseFloat(e.target.value);
            this.updateSelected();
        });
        
        ['strokeStyle', 'strokeLinecap', 'strokeLinejoin'].forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                const prop = id.replace('stroke', '').toLowerCase();
                this.currentStroke[prop] = e.target.value;
                this.updateSelected();
            });
        });
    }
    
    setupGradientControls() {
        document.getElementById('gradientAngle').addEventListener('change', (e) => {
            this.currentGradient.angle = parseFloat(e.target.value);
            this.updateGradientPreview();
            this.updateSelected();
        });
        
        document.getElementById('addGradientStop').addEventListener('click', () => {
            this.currentGradient.stops.push({ offset: 0.5, color: '#ffffff' });
            this.currentGradient.stops.sort((a, b) => a.offset - b.offset);
            this.updateGradientUI();
            this.updateSelected();
        });
        
        this.updateGradientUI();
    }
    
    updateGradientUI() {
        const stopsContainer = document.getElementById('gradientStops');
        const stopsList = document.getElementById('gradientStopsList');
        
        this.updateGradientPreview();
        
        // Stops markers
        stopsContainer.innerHTML = '';
        this.currentGradient.stops.forEach((stop, i) => {
            const marker = document.createElement('div');
            marker.className = 'gradient-stop';
            marker.style.left = (stop.offset * 100) + '%';
            marker.style.background = stop.color;
            stopsContainer.appendChild(marker);
        });
        
        // Stops list
        stopsList.innerHTML = '';
        this.currentGradient.stops.forEach((stop, i) => {
            const row = document.createElement('div');
            row.className = 'prop-row';
            row.innerHTML = `
                <input type="color" value="${stop.color}" style="width: 32px; height: 32px; padding: 0; border: none; cursor: pointer;">
                <input type="number" class="prop-input" value="${Math.round(stop.offset * 100)}" min="0" max="100" style="width: 60px;">
                <span class="prop-label">%</span>
                ${this.currentGradient.stops.length > 2 ? `<button class="btn btn-sm" style="padding: 4px 8px;">✕</button>` : ''}
            `;
            
            const colorInput = row.querySelector('input[type="color"]');
            const offsetInput = row.querySelector('input[type="number"]');
            const deleteBtn = row.querySelector('button');
            
            colorInput.addEventListener('input', (e) => {
                this.currentGradient.stops[i].color = e.target.value;
                this.updateGradientUI();
                this.updateSelected();
            });
            
            offsetInput.addEventListener('change', (e) => {
                this.currentGradient.stops[i].offset = parseFloat(e.target.value) / 100;
                this.currentGradient.stops.sort((a, b) => a.offset - b.offset);
                this.updateGradientUI();
                this.updateSelected();
            });
            
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    this.currentGradient.stops.splice(i, 1);
                    this.updateGradientUI();
                    this.updateSelected();
                });
            }
            
            stopsList.appendChild(row);
        });
    }
    
    updateGradientPreview() {
        const preview = document.getElementById('gradientPreview');
        const stops = this.currentGradient.stops.map(s => `${s.color} ${s.offset * 100}%`).join(', ');
        
        if (this.currentGradient.type === 'linear') {
            preview.style.background = `linear-gradient(${this.currentGradient.angle}deg, ${stops})`;
        } else {
            preview.style.background = `radial-gradient(circle, ${stops})`;
        }
    }
    
    updateFillUI() {
        const solidSection = document.getElementById('solidFillSection');
        const gradientSection = document.getElementById('gradientFillSection');
        const angleRow = document.getElementById('gradientAngleRow');

        if (this.currentFill.type === 'solid') {
            solidSection.classList.remove('hidden');
            gradientSection.classList.add('hidden');
        } else if (this.currentFill.type === 'none') {
            solidSection.classList.add('hidden');
            gradientSection.classList.add('hidden');
        } else {
            solidSection.classList.add('hidden');
            gradientSection.classList.remove('hidden');
            this.currentGradient.type = this.currentFill.type;
            angleRow.style.display = this.currentFill.type === 'linear' ? 'flex' : 'none';
            this.updateGradientUI();
        }
    }

    // ==================== EFFECTS ====================

    setupEffectsControls() {
        // Shadow toggle
        const shadowToggle = document.getElementById('shadowToggle');
        const shadowControls = document.getElementById('shadowControls');
        shadowToggle.addEventListener('click', () => {
            shadowToggle.classList.toggle('active');
            shadowControls.classList.toggle('hidden');
            this.applyEffectsToSelected();
        });

        // Shadow controls
        ['shadowX', 'shadowY', 'shadowBlur', 'shadowOpacity'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => this.applyEffectsToSelected());
        });

        // Shadow color
        document.getElementById('shadowColorSwatch').addEventListener('click', () => {
            document.getElementById('shadowColorPicker').click();
        });
        document.getElementById('shadowColorPicker').addEventListener('input', (e) => {
            document.getElementById('shadowSwatchInner').style.background = e.target.value;
            this.applyEffectsToSelected();
        });

        // Blur toggle
        const blurToggle = document.getElementById('blurToggle');
        const blurControls = document.getElementById('blurControls');
        blurToggle.addEventListener('click', () => {
            blurToggle.classList.toggle('active');
            blurControls.classList.toggle('hidden');
            this.applyEffectsToSelected();
        });

        // Blur amount
        document.getElementById('blurAmount').addEventListener('input', (e) => {
            document.getElementById('blurValue').textContent = e.target.value + 'px';
            this.applyEffectsToSelected();
        });
    }

    applyEffectsToSelected() {
        if (this.selectedElements.length === 0) return;

        const shadowEnabled = document.getElementById('shadowToggle').classList.contains('active');
        const blurEnabled = document.getElementById('blurToggle').classList.contains('active');

        this.selectedElements.forEach(el => {
            // Apply shadow
            if (shadowEnabled) {
                el.shadow = {
                    enabled: true,
                    x: parseFloat(document.getElementById('shadowX').value) || 4,
                    y: parseFloat(document.getElementById('shadowY').value) || 4,
                    blur: parseFloat(document.getElementById('shadowBlur').value) || 8,
                    opacity: parseFloat(document.getElementById('shadowOpacity').value) || 0.3,
                    color: document.getElementById('shadowColorPicker').value || '#000000'
                };
            } else {
                el.shadow = { enabled: false };
            }

            // Apply blur
            if (blurEnabled) {
                el.blur = {
                    enabled: true,
                    amount: parseFloat(document.getElementById('blurAmount').value) || 5
                };
            } else {
                el.blur = { enabled: false };
            }
        });

        this.render();
        this.updateCodeEditor();
    }

    updateEffectsUI(el) {
        const shadowToggle = document.getElementById('shadowToggle');
        const shadowControls = document.getElementById('shadowControls');
        const blurToggle = document.getElementById('blurToggle');
        const blurControls = document.getElementById('blurControls');

        // Reset to defaults
        shadowToggle.classList.remove('active');
        shadowControls.classList.add('hidden');
        blurToggle.classList.remove('active');
        blurControls.classList.add('hidden');

        if (!el) return;

        // Shadow
        if (el.shadow && el.shadow.enabled) {
            shadowToggle.classList.add('active');
            shadowControls.classList.remove('hidden');
            document.getElementById('shadowX').value = el.shadow.x || 4;
            document.getElementById('shadowY').value = el.shadow.y || 4;
            document.getElementById('shadowBlur').value = el.shadow.blur || 8;
            document.getElementById('shadowOpacity').value = el.shadow.opacity || 0.3;
            document.getElementById('shadowColorPicker').value = el.shadow.color || '#000000';
            document.getElementById('shadowSwatchInner').style.background = el.shadow.color || '#000000';
        }

        // Blur
        if (el.blur && el.blur.enabled) {
            blurToggle.classList.add('active');
            blurControls.classList.remove('hidden');
            document.getElementById('blurAmount').value = el.blur.amount || 5;
            document.getElementById('blurValue').textContent = (el.blur.amount || 5) + 'px';
        }
    }

    // ==================== TRACE MODE ====================
    
    setupTraceMode() {
        const dropZone = document.getElementById('dropZone');
        const imageInput = document.getElementById('imageInput');
        
        dropZone.addEventListener('click', () => imageInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                this.loadTraceImage(file);
            }
        });
        
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) this.loadTraceImage(file);
        });
        
        document.getElementById('removeImageBtn').addEventListener('click', () => {
            this.traceImage = null;
            document.getElementById('imagePreviewContainer').classList.add('hidden');
            document.getElementById('traceControls').classList.add('hidden');
            document.getElementById('dropZone').classList.remove('hidden');
            document.getElementById('paletteContainer').classList.add('hidden');
            document.getElementById('traceStatus').classList.add('hidden');
        });
        
        // Trace mode select
        document.getElementById('traceMode').addEventListener('change', (e) => {
            const mode = e.target.value;
            document.getElementById('thresholdGroup').style.display = mode === 'bw' ? 'block' : 'none';
            document.getElementById('colorCountGroup').style.display = mode !== 'bw' ? 'block' : 'none';
            // Auto-detect colors when switching to color mode
            if (mode !== 'bw' && this.traceImage) {
                this.analyzeImageColors();
            }
        });

        // Quality preset select
        document.getElementById('traceQuality').addEventListener('change', (e) => {
            this.applyQualityPreset(e.target.value);
        });

        // Detail level slider
        document.getElementById('detailLevel').addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            const labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
            document.getElementById('detailLevelValue').textContent = labels[level - 1];
            this.applyDetailLevel(level);
        });

        // Toggle advanced settings
        document.getElementById('toggleAdvanced').addEventListener('click', () => {
            const advanced = document.getElementById('advancedSettings');
            const btn = document.getElementById('toggleAdvanced');
            advanced.classList.toggle('hidden');
            btn.textContent = advanced.classList.contains('hidden') ? 'Show Advanced Settings' : 'Hide Advanced Settings';
        });

        // Auto color detection button
        document.getElementById('autoColorBtn').addEventListener('click', () => {
            if (this.traceImage) {
                this.analyzeImageColors();
            }
        });

        // Sliders
        const sliders = {
            'threshold': 'thresholdValue',
            'colorCount': 'colorCountValue',
            'tolerance': 'toleranceValue',
            'minArea': 'minAreaValue',
            'cornerThreshold': 'cornerValue'
        };

        Object.entries(sliders).forEach(([sliderId, valueId]) => {
            document.getElementById(sliderId).addEventListener('input', (e) => {
                document.getElementById(valueId).textContent = e.target.value;
            });
        });

        // Toggles
        ['smoothToggle', 'invertToggle', 'removeBgToggle'].forEach(id => {
            document.getElementById(id).addEventListener('click', (e) => {
                e.currentTarget.classList.toggle('active');
            });
        });

        // Trace button
        document.getElementById('traceBtn').addEventListener('click', () => this.traceImage && this.performTrace());

        // Setup Edit Mode controls
        this.setupEditModeControls();
    }

    setupEditModeControls() {
        // Edit tool buttons
        document.querySelectorAll('[data-edit-tool]').forEach(btn => {
            btn.addEventListener('click', () => this.selectEditTool(btn.dataset.editTool));
        });

        // Brush settings sliders
        document.getElementById('brushRadius').addEventListener('input', (e) => {
            document.getElementById('brushRadiusValue').textContent = e.target.value;
            this.brushRadius = parseInt(e.target.value);
        });

        document.getElementById('brushStrength').addEventListener('input', (e) => {
            document.getElementById('brushStrengthValue').textContent = e.target.value + '%';
            this.brushStrength = parseInt(e.target.value) / 100;
        });

        document.getElementById('brushFalloff').addEventListener('change', (e) => {
            this.brushFalloff = e.target.value;
        });

        // Node properties
        document.getElementById('nodeType').addEventListener('change', (e) => {
            if (this.selectedNode) {
                this.selectedNode.type = e.target.value;
                this.rebuildPathFromNodes();
            }
        });

        ['nodeX', 'nodeY'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (this.selectedNode) {
                    this.selectedNode.x = parseFloat(document.getElementById('nodeX').value);
                    this.selectedNode.y = parseFloat(document.getElementById('nodeY').value);
                    this.rebuildPathFromNodes();
                }
            });
        });

        // Path operations
        document.getElementById('closePathBtn').addEventListener('click', () => this.closeSelectedPath());
        document.getElementById('reversePathBtn').addEventListener('click', () => this.reverseSelectedPath());
        document.getElementById('simplifyPathBtn').addEventListener('click', () => this.simplifySelectedPath());

        // Initialize brush settings
        this.brushRadius = 30;
        this.brushStrength = 0.5;
        this.brushFalloff = 'soft';
    }

    selectEditTool(tool) {
        this.editTool = tool;
        document.querySelectorAll('[data-edit-tool]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.editTool === tool);
        });

        // Show/hide brush settings based on tool
        const brushTools = ['smooth-brush', 'expand-brush', 'shrink-brush'];
        const brushSettingsGroup = document.getElementById('brushSettingsGroup');
        if (brushTools.includes(tool)) {
            brushSettingsGroup.style.display = 'block';
            this.canvas.style.cursor = 'crosshair';
        } else {
            // brushSettingsGroup.style.display = 'none';
            this.canvas.style.cursor = 'default';
        }
    }

    closeSelectedPath() {
        if (this.selectedElements.length !== 1) return;
        const el = this.selectedElements[0];
        if (el.type === 'path' && el.d) {
            if (!el.d.trim().toUpperCase().endsWith('Z')) {
                el.d = el.d.trim() + ' Z';
                this.render();
                this.renderEditMode();
                this.saveToHistory();
            }
        }
    }

    reverseSelectedPath() {
        if (this.selectedElements.length !== 1) return;
        const el = this.selectedElements[0];
        if (el.type === 'polygon' && el._editNodes) {
            el._editNodes.reverse();
            this.rebuildPolygonFromNodes(el);
        }
    }

    simplifySelectedPath() {
        if (this.selectedElements.length !== 1) return;
        const el = this.selectedElements[0];
        if (el.type === 'polygon' && el._editNodes) {
            // Douglas-Peucker simplification
            const tolerance = 2;
            el._editNodes = this.simplifyPath(el._editNodes.map(n => [n.x, n.y]), tolerance)
                .map(p => ({ x: p[0], y: p[1], type: 'corner' }));
            this.rebuildPolygonFromNodes(el);
        }
    }

    rebuildPolygonFromNodes(el) {
        if (!el._editNodes) return;
        el.points = el._editNodes.map(n => `${n.x},${n.y}`).join(' ');
        this.render();
        this.renderEditMode();
        this.updateCodeEditor();
        this.saveToHistory();
    }

    rebuildPathFromNodes() {
        if (this.selectedElements.length !== 1) return;
        const el = this.selectedElements[0];
        if (el.type === 'polygon') {
            this.rebuildPolygonFromNodes(el);
        }
        // Path rebuilding would be more complex - for now just re-render
        this.render();
        this.renderEditMode();
    }

    applyQualityPreset(preset) {
        const presets = {
            fast: { tolerance: 4, minArea: 10, cornerThreshold: 90, kmeans: 10 },
            balanced: { tolerance: 2, minArea: 4, cornerThreshold: 60, kmeans: 20 },
            high: { tolerance: 0.5, minArea: 1, cornerThreshold: 30, kmeans: 30 }
        };

        const settings = presets[preset];
        document.getElementById('tolerance').value = settings.tolerance;
        document.getElementById('toleranceValue').textContent = settings.tolerance;
        document.getElementById('minArea').value = settings.minArea;
        document.getElementById('minAreaValue').textContent = settings.minArea;
        document.getElementById('cornerThreshold').value = settings.cornerThreshold;
        document.getElementById('cornerValue').textContent = settings.cornerThreshold;

        // Store kmeans iterations for use in tracing
        this.kmeansIterations = settings.kmeans;
    }

    applyDetailLevel(level) {
        // Map detail level 1-5 to tolerance, minArea settings
        const settings = [
            { tolerance: 5, minArea: 20 },   // 1 - Very Low
            { tolerance: 3, minArea: 10 },   // 2 - Low
            { tolerance: 2, minArea: 4 },    // 3 - Medium
            { tolerance: 1, minArea: 2 },    // 4 - High
            { tolerance: 0.3, minArea: 1 }   // 5 - Very High
        ];

        const s = settings[level - 1];
        document.getElementById('tolerance').value = s.tolerance;
        document.getElementById('toleranceValue').textContent = s.tolerance;
        document.getElementById('minArea').value = s.minArea;
        document.getElementById('minAreaValue').textContent = s.minArea;
    }

    analyzeImageColors() {
        if (!this.traceImage) return;

        // Create temp canvas
        const tempCanvas = document.createElement('canvas');
        const maxSampleSize = 200; // Sample at reduced size for speed
        const scale = Math.min(maxSampleSize / this.traceImage.width, maxSampleSize / this.traceImage.height, 1);
        tempCanvas.width = Math.round(this.traceImage.width * scale);
        tempCanvas.height = Math.round(this.traceImage.height * scale);
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(this.traceImage, 0, 0, tempCanvas.width, tempCanvas.height);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;

        // Count unique colors using a color hash
        const colorSet = new Set();
        const colorTolerance = 16; // Group similar colors

        for (let i = 0; i < data.length; i += 4) {
            const r = Math.floor(data[i] / colorTolerance) * colorTolerance;
            const g = Math.floor(data[i + 1] / colorTolerance) * colorTolerance;
            const b = Math.floor(data[i + 2] / colorTolerance) * colorTolerance;
            colorSet.add(`${r},${g},${b}`);
        }

        const detectedColors = Math.min(colorSet.size, 512);
        document.getElementById('detectedColorsValue').textContent = detectedColors;

        // Set color count slider to detected colors (capped at 256 for UI)
        const colorCountSlider = document.getElementById('colorCount');
        const suggestedColors = Math.min(detectedColors, 256);
        colorCountSlider.max = Math.min(detectedColors, 512);
        colorCountSlider.value = suggestedColors;
        document.getElementById('colorCountValue').textContent = suggestedColors;
    }
    
    loadTraceImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.traceImage = img;
                document.getElementById('imagePreview').src = e.target.result;
                document.getElementById('imagePreviewContainer').classList.remove('hidden');
                document.getElementById('traceControls').classList.remove('hidden');
                document.getElementById('dropZone').classList.add('hidden');

                // Resize canvas
                this.canvasWidth = Math.min(img.width, 1200);
                this.canvasHeight = Math.min(img.height, 900);
                const scale = Math.min(this.canvasWidth / img.width, this.canvasHeight / img.height);
                this.canvasWidth = Math.round(img.width * scale);
                this.canvasHeight = Math.round(img.height * scale);

                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                this.selectionCanvas.width = this.canvasWidth;
                this.selectionCanvas.height = this.canvasHeight;

                this.ctx.drawImage(img, 0, 0, this.canvasWidth, this.canvasHeight);

                // Auto-detect colors if in color mode
                const mode = document.getElementById('traceMode').value;
                if (mode !== 'bw') {
                    this.analyzeImageColors();
                }
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    async performTrace() {
        if (!this.traceImage) return;
        
        const progressContainer = document.getElementById('traceProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        
        progressContainer.classList.remove('hidden');
        progressFill.style.width = '0%';
        progressText.textContent = 'Processing image...';
        
        const mode = document.getElementById('traceMode').value;
        const threshold = parseInt(document.getElementById('threshold').value);
        const colorCount = parseInt(document.getElementById('colorCount').value);
        const tolerance = parseFloat(document.getElementById('tolerance').value);
        const minArea = parseInt(document.getElementById('minArea').value);
        const cornerThreshold = parseInt(document.getElementById('cornerThreshold').value);
        const smooth = document.getElementById('smoothToggle').classList.contains('active');
        const invert = document.getElementById('invertToggle').classList.contains('active');
        const removeBg = document.getElementById('removeBgToggle').classList.contains('active');
        
        // Create temp canvas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.canvasWidth;
        tempCanvas.height = this.canvasHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(this.traceImage, 0, 0, this.canvasWidth, this.canvasHeight);
        
        const imageData = tempCtx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);
        
        progressFill.style.width = '20%';
        progressText.textContent = 'Analyzing colors...';
        
        await new Promise(r => setTimeout(r, 50));
        
        let paths = [];
        
        if (mode === 'bw') {
            paths = await this.traceBW(imageData, threshold, tolerance, minArea, cornerThreshold, smooth, invert);
        } else {
            paths = await this.traceColor(imageData, colorCount, tolerance, minArea, cornerThreshold, smooth, mode === 'grayscale', removeBg, progressFill, progressText);
        }
        
        progressFill.style.width = '90%';
        progressText.textContent = 'Creating vectors...';
        
        await new Promise(r => setTimeout(r, 50));
        
        // Add paths as elements
        this.elements = [];
        paths.forEach((pathData, i) => {
            this.elements.push({
                id: 'path_' + Date.now() + '_' + i,
                type: 'path',
                d: pathData.d,
                fill: pathData.fill,
                stroke: { enabled: false },
                opacity: 1,
                name: `Path ${i + 1}`
            });
        });
        
        progressFill.style.width = '100%';
        progressText.textContent = 'Complete!';
        
        // Show status
        document.getElementById('traceStatus').classList.remove('hidden');
        document.getElementById('traceStatusInfo').textContent = `${paths.length} paths generated`;
        
        setTimeout(() => {
            progressContainer.classList.add('hidden');
            this.switchMode('create');
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.showToast(`Traced ${paths.length} paths successfully!`, 'success');
        }, 500);
    }
    
    async traceBW(imageData, threshold, tolerance, minArea, cornerThreshold, smooth, invert) {
        const { width, height, data } = imageData;
        
        // Convert to binary
        const binary = new Array(height).fill(null).map(() => new Array(width).fill(0));
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const gray = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                let isBlack = gray < threshold;
                if (invert) isBlack = !isBlack;
                binary[y][x] = isBlack ? 1 : 0;
            }
        }
        
        // Find contours
        const contours = this.findContours(binary, width, height, minArea);
        
        return contours.map(contour => {
            const simplified = this.simplifyPath(contour, tolerance);
            const d = this.pointsToPath(simplified, smooth, cornerThreshold);
            return { d, fill: { type: 'solid', color: '#000000', alpha: 1 } };
        });
    }
    
    async traceColor(imageData, colorCount, tolerance, minArea, cornerThreshold, smooth, grayscale, removeBg, progressFill, progressText) {
        const { width, height, data } = imageData;
        
        progressText.textContent = 'Quantizing colors...';
        const palette = this.quantizeColors(data, colorCount, grayscale);
        
        this.showExtractedPalette(palette);
        progressFill.style.width = '40%';
        
        // Create layers per color
        const colorLayers = new Map();
        palette.forEach(color => {
            colorLayers.set(color, new Array(height).fill(null).map(() => new Array(width).fill(0)));
        });
        
        // Assign pixels
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
                
                if (a < 128) continue;
                
                const nearestColor = this.findNearestColor([r, g, b], palette);
                colorLayers.get(nearestColor)[y][x] = 1;
            }
        }
        
        progressFill.style.width = '60%';
        progressText.textContent = 'Tracing contours...';
        
        await new Promise(r => setTimeout(r, 50));
        
        const paths = [];
        let colorIndex = 0;
        
        for (const [colorHex, layer] of colorLayers) {
            if (removeBg && colorIndex === 0) {
                colorIndex++;
                continue;
            }
            
            const contours = this.findContours(layer, width, height, minArea);
            
            contours.forEach(contour => {
                const simplified = this.simplifyPath(contour, tolerance);
                if (simplified.length >= 3) {
                    const d = this.pointsToPath(simplified, smooth, cornerThreshold);
                    paths.push({ 
                        d, 
                        fill: { type: 'solid', color: colorHex, alpha: 1 }
                    });
                }
            });
            
            colorIndex++;
            progressFill.style.width = (60 + (colorIndex / palette.length) * 30) + '%';
        }
        
        return paths;
    }
    
    quantizeColors(data, colorCount, grayscale) {
        const colors = [];

        for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] < 128) continue;

            let r = data[i], g = data[i + 1], b = data[i + 2];

            if (grayscale) {
                const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
                r = g = b = gray;
            }

            colors.push([r, g, b]);
        }

        // Sample for performance - increase for high quality
        const quality = document.getElementById('traceQuality').value;
        const sampleMultiplier = quality === 'high' ? 2 : quality === 'fast' ? 0.5 : 1;
        const sampleSize = Math.min(colors.length, Math.round(50000 * sampleMultiplier));
        const sampled = [];
        for (let i = 0; i < sampleSize; i++) {
            sampled.push(colors[Math.floor(Math.random() * colors.length)]);
        }

        // K-means clustering with dynamic iterations
        const iterations = this.kmeansIterations || 20;
        let centroids = [];
        for (let i = 0; i < colorCount; i++) {
            centroids.push(sampled[Math.floor(Math.random() * sampled.length)]);
        }

        for (let iter = 0; iter < iterations; iter++) {
            const clusters = centroids.map(() => []);

            sampled.forEach(color => {
                let minDist = Infinity;
                let minIndex = 0;
                centroids.forEach((centroid, i) => {
                    // Use perceptual color distance (weighted RGB)
                    const dr = color[0] - centroid[0];
                    const dg = color[1] - centroid[1];
                    const db = color[2] - centroid[2];
                    // Weighted for human perception (red less sensitive, green most)
                    const dist = Math.sqrt(dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11);
                    if (dist < minDist) {
                        minDist = dist;
                        minIndex = i;
                    }
                });
                clusters[minIndex].push(color);
            });

            centroids = clusters.map((cluster, i) => {
                if (cluster.length === 0) return centroids[i];
                const avg = [0, 0, 0];
                cluster.forEach(c => {
                    avg[0] += c[0];
                    avg[1] += c[1];
                    avg[2] += c[2];
                });
                return [
                    Math.round(avg[0] / cluster.length),
                    Math.round(avg[1] / cluster.length),
                    Math.round(avg[2] / cluster.length)
                ];
            });
        }

        return centroids.map(c => this.rgbToHex(c[0], c[1], c[2]));
    }
    
    findNearestColor(rgb, palette) {
        let minDist = Infinity;
        let nearest = palette[0];
        
        palette.forEach(hex => {
            const c = this.hexToRgb(hex);
            const dist = Math.sqrt(
                Math.pow(rgb[0] - c.r, 2) +
                Math.pow(rgb[1] - c.g, 2) +
                Math.pow(rgb[2] - c.b, 2)
            );
            if (dist < minDist) {
                minDist = dist;
                nearest = hex;
            }
        });
        
        return nearest;
    }
    
    showExtractedPalette(palette) {
        const container = document.getElementById('paletteContainer');
        const display = document.getElementById('paletteDisplay');
        
        display.innerHTML = '';
        palette.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'palette-color';
            swatch.style.background = color;
            swatch.title = color;
            display.appendChild(swatch);
        });
        
        container.classList.remove('hidden');
    }
    
    findContours(binary, width, height, minArea) {
        const visited = new Array(height).fill(null).map(() => new Array(width).fill(false));
        const contours = [];
        
        const directions = [
            [0, -1], [1, -1], [1, 0], [1, 1],
            [0, 1], [-1, 1], [-1, 0], [-1, -1]
        ];
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (binary[y][x] === 1 && !visited[y][x]) {
                    const contour = [];
                    const startX = x, startY = y;
                    let cx = x, cy = y;
                    let dir = 0;
                    
                    do {
                        contour.push({ x: cx, y: cy });
                        visited[cy][cx] = true;
                        
                        let found = false;
                        for (let i = 0; i < 8; i++) {
                            const newDir = (dir + i) % 8;
                            const nx = cx + directions[newDir][0];
                            const ny = cy + directions[newDir][1];
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height && binary[ny][nx] === 1) {
                                cx = nx;
                                cy = ny;
                                dir = (newDir + 5) % 8;
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found) break;
                        
                    } while (!(cx === startX && cy === startY) && contour.length < 100000);
                    
                    if (contour.length >= minArea) {
                        contours.push(contour);
                    }
                }
            }
        }
        
        return contours;
    }
    
    simplifyPath(points, tolerance) {
        if (points.length <= 2) return points;
        
        const sqTolerance = tolerance * tolerance;
        
        const getSqSegDist = (p, p1, p2) => {
            let x = p1.x, y = p1.y;
            let dx = p2.x - x, dy = p2.y - y;
            
            if (dx !== 0 || dy !== 0) {
                const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
            
            dx = p.x - x;
            dy = p.y - y;
            return dx * dx + dy * dy;
        };
        
        const simplifyDPStep = (points, first, last, sqTolerance, simplified) => {
            let maxSqDist = sqTolerance;
            let index = 0;
            
            for (let i = first + 1; i < last; i++) {
                const sqDist = getSqSegDist(points[i], points[first], points[last]);
                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }
            
            if (maxSqDist > sqTolerance) {
                if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
                simplified.push(points[index]);
                if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
            }
        };
        
        const last = points.length - 1;
        const simplified = [points[0]];
        simplifyDPStep(points, 0, last, sqTolerance, simplified);
        simplified.push(points[last]);
        
        return simplified;
    }
    
    pointsToPath(points, smooth, cornerThreshold) {
        if (points.length < 2) return '';
        
        const cornerRad = cornerThreshold * Math.PI / 180;
        let d = `M ${points[0].x} ${points[0].y}`;
        
        if (smooth && points.length > 2) {
            for (let i = 1; i < points.length; i++) {
                const p0 = points[i - 1];
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                
                const v1 = { x: p1.x - p0.x, y: p1.y - p0.y };
                const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };
                const angle = Math.abs(Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x));
                
                if (angle > cornerRad && angle < Math.PI * 2 - cornerRad) {
                    d += ` L ${p1.x} ${p1.y}`;
                } else {
                    const cp1x = p0.x + (p1.x - p0.x) * 0.5;
                    const cp1y = p0.y + (p1.y - p0.y) * 0.5;
                    const cp2x = p1.x - (p2.x - p0.x) * 0.25;
                    const cp2y = p1.y - (p2.y - p0.y) * 0.25;
                    d += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p1.x} ${p1.y}`;
                }
            }
        } else {
            for (let i = 1; i < points.length; i++) {
                d += ` L ${points[i].x} ${points[i].y}`;
            }
        }
        
        d += ' Z';
        return d;
    }
    
    // ==================== COLOR UTILITIES ====================
    
    rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
    
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }
    
    hexToRgba(hex, alpha) {
        const rgb = this.hexToRgb(hex);
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }

    // ==================== PEN TOOL HELPERS ====================

    simplifyPenPath(points, tolerance) {
        if (points.length < 3) return points;

        // Douglas-Peucker simplification
        const sqTolerance = tolerance * tolerance;

        const getSqDist = (p1, p2) => {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return dx * dx + dy * dy;
        };

        const getSqSegDist = (p, p1, p2) => {
            let x = p1.x, y = p1.y;
            let dx = p2.x - x, dy = p2.y - y;
            if (dx !== 0 || dy !== 0) {
                const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) { x = p2.x; y = p2.y; }
                else if (t > 0) { x += dx * t; y += dy * t; }
            }
            dx = p.x - x; dy = p.y - y;
            return dx * dx + dy * dy;
        };

        const simplifyDPStep = (points, first, last, sqTolerance, simplified) => {
            let maxSqDist = sqTolerance, index;
            for (let i = first + 1; i < last; i++) {
                const sqDist = getSqSegDist(points[i], points[first], points[last]);
                if (sqDist > maxSqDist) { index = i; maxSqDist = sqDist; }
            }
            if (maxSqDist > sqTolerance) {
                if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
                simplified.push(points[index]);
                if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
            }
        };

        const last = points.length - 1;
        const simplified = [points[0]];
        simplifyDPStep(points, 0, last, sqTolerance, simplified);
        simplified.push(points[last]);

        return simplified;
    }

    penPointsToSVGPath(points) {
        if (points.length < 2) return '';

        let d = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;

        if (points.length === 2) {
            d += ` L ${points[1].x.toFixed(1)} ${points[1].y.toFixed(1)}`;
            return d;
        }

        // Create smooth curves using quadratic beziers
        for (let i = 1; i < points.length - 1; i++) {
            const p0 = points[i - 1];
            const p1 = points[i];
            const p2 = points[i + 1];

            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            d += ` Q ${p1.x.toFixed(1)} ${p1.y.toFixed(1)} ${midX.toFixed(1)} ${midY.toFixed(1)}`;
        }

        // Add the last point
        const last = points[points.length - 1];
        d += ` L ${last.x.toFixed(1)} ${last.y.toFixed(1)}`;

        return d;
    }

    // ==================== TEXT TOOL ====================

    createTextElement(x, y) {
        // Remove any existing text input
        if (this.activeTextInput) {
            this.activeTextInput.remove();
            this.activeTextInput = null;
        }

        // Create an input overlay for text entry
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'text-input-overlay';

        const rect = this.canvas.getBoundingClientRect();
        const posX = x * this.zoom + rect.left + this.pan.x * this.zoom;
        const posY = y * this.zoom + rect.top + this.pan.y * this.zoom;

        input.style.cssText = `
            position: fixed;
            left: ${posX}px;
            top: ${posY}px;
            font-size: 18px;
            font-family: var(--font-main);
            background: var(--bg-input);
            border: 2px solid var(--accent);
            border-radius: var(--radius-xs);
            color: var(--text);
            padding: 6px 10px;
            min-width: 150px;
            outline: none;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        input.placeholder = 'Type text and press Enter...';

        let isFinished = false;

        const finishText = (createText = true) => {
            if (isFinished) return;
            isFinished = true;

            const text = input.value.trim();
            if (text && createText) {
                const element = {
                    id: 'text_' + Date.now(),
                    type: 'text',
                    x: x,
                    y: y + 24, // Offset Y so text baseline aligns with click point
                    text: text,
                    fontSize: 24,
                    fontFamily: 'Plus Jakarta Sans',
                    fill: JSON.parse(JSON.stringify(this.currentFill)),
                    stroke: { enabled: false, color: '#000000', width: 1, style: 'solid', linecap: 'round', linejoin: 'round' },
                    opacity: 1,
                    name: 'Text'
                };

                this.elements.push(element);
                this.selectedElements = [element];
                this.render();
                this.updateLayersList();
                this.updateCodeEditor();
                this.updatePropertiesPanel();
                this.saveToHistory();
                this.saveToLocalStorage();
            }

            if (input.parentNode) {
                input.remove();
            }
            this.activeTextInput = null;
        };

        input.addEventListener('blur', () => {
            // Small delay to allow Enter key to process first
            setTimeout(() => finishText(true), 100);
        });

        input.addEventListener('keydown', (e) => {
            e.stopPropagation(); // Prevent global keyboard shortcuts
            if (e.key === 'Enter') {
                e.preventDefault();
                finishText(true);
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                finishText(false);
            }
        });

        document.body.appendChild(input);

        // Focus after appending to DOM
        requestAnimationFrame(() => {
            input.focus();
            input.select();
        });

        this.activeTextInput = input;
    }

    // ==================== MODE & TOOL SWITCHING ====================
    
    switchMode(mode) {
        this.currentMode = mode;

        document.querySelectorAll('.mode-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.mode === mode);
        });

        const createContent = document.querySelector('.create-mode-content');
        const traceContent = document.querySelector('.trace-mode-content');
        const editContent = document.querySelector('.edit-mode-content');

        createContent.classList.add('hidden');
        traceContent.classList.add('hidden');
        editContent.classList.add('hidden');

        if (mode === 'create') {
            createContent.classList.remove('hidden');
            this.render();
        } else if (mode === 'trace') {
            traceContent.classList.remove('hidden');
            // Draw trace image if available
            if (this.traceImage) {
                this.ctx.drawImage(this.traceImage, 0, 0, this.canvasWidth, this.canvasHeight);
            }
        } else if (mode === 'edit') {
            editContent.classList.remove('hidden');
            this.editTool = this.editTool || 'node-select';
            this.render();
            this.renderEditMode();
        }
    }

    renderEditMode() {
        if (this.currentMode !== 'edit') return;

        const hint = document.getElementById('editModeHint');
        const toolsGroup = document.getElementById('editToolsGroup');

        // Check if a path or polygon is selected
        const hasEditableSelection = this.selectedElements.length === 1 &&
            (this.selectedElements[0].type === 'path' || this.selectedElements[0].type === 'polygon');

        // Show/hide hint based on selection
        if (hint) {
            hint.classList.toggle('hidden', hasEditableSelection);
        }

        // Show node handles on selected path elements
        if (hasEditableSelection) {
            const el = this.selectedElements[0];
            this.drawPathNodes(el);
        } else {
            // Clear selection canvas when nothing editable is selected
            this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        }
    }

    drawPathNodes(el) {
        this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

        let points = [];

        if (el.type === 'polygon') {
            // Parse polygon points
            points = el.points.split(' ').map(p => {
                const [x, y] = p.split(',').map(Number);
                return { x, y, type: 'corner' };
            });
        } else if (el.type === 'path' && el.d) {
            // Parse path d attribute (simplified - handles M, L, C, Z)
            points = this.parsePathPoints(el.d);
        }

        // Store for interaction
        el._editNodes = points;

        // Draw nodes
        points.forEach((pt, i) => {
            this.selectionCtx.beginPath();
            this.selectionCtx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);

            if (pt === this.selectedNode) {
                this.selectionCtx.fillStyle = '#6366f1';
            } else if (pt.type === 'control') {
                this.selectionCtx.fillStyle = 'transparent';
                this.selectionCtx.strokeStyle = '#6366f1';
                this.selectionCtx.lineWidth = 1;
                this.selectionCtx.stroke();
            } else {
                this.selectionCtx.fillStyle = '#ffffff';
                this.selectionCtx.strokeStyle = '#6366f1';
                this.selectionCtx.lineWidth = 2;
                this.selectionCtx.stroke();
            }
            this.selectionCtx.fill();
        });
    }

    parsePathPoints(d) {
        const points = [];
        const commands = d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi) || [];

        let currentX = 0, currentY = 0;

        commands.forEach(cmd => {
            const type = cmd[0].toUpperCase();
            const args = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter(n => !isNaN(n));

            switch (type) {
                case 'M':
                case 'L':
                    for (let i = 0; i < args.length; i += 2) {
                        currentX = args[i];
                        currentY = args[i + 1];
                        points.push({ x: currentX, y: currentY, type: 'corner' });
                    }
                    break;
                case 'H':
                    currentX = args[0];
                    points.push({ x: currentX, y: currentY, type: 'corner' });
                    break;
                case 'V':
                    currentY = args[0];
                    points.push({ x: currentX, y: currentY, type: 'corner' });
                    break;
                case 'C':
                    // Cubic bezier: cp1x, cp1y, cp2x, cp2y, x, y
                    for (let i = 0; i < args.length; i += 6) {
                        points.push({ x: args[i], y: args[i + 1], type: 'control' });
                        points.push({ x: args[i + 2], y: args[i + 3], type: 'control' });
                        currentX = args[i + 4];
                        currentY = args[i + 5];
                        points.push({ x: currentX, y: currentY, type: 'smooth' });
                    }
                    break;
                case 'Q':
                    // Quadratic bezier
                    for (let i = 0; i < args.length; i += 4) {
                        points.push({ x: args[i], y: args[i + 1], type: 'control' });
                        currentX = args[i + 2];
                        currentY = args[i + 3];
                        points.push({ x: currentX, y: currentY, type: 'smooth' });
                    }
                    break;
            }
        });

        return points;
    }

    handleEditModeMouseDown(x, y, e) {
        const el = this.selectedElements[0];

        // First, try to select an element if none selected or clicking elsewhere
        if (!el || el.type !== 'path' && el.type !== 'polygon') {
            const clicked = this.getElementAtPoint(x, y);
            if (clicked && (clicked.type === 'path' || clicked.type === 'polygon')) {
                this.selectedElements = [clicked];
                this.render();
                this.renderEditMode();
                this.updatePropertiesPanel();
            }
            return;
        }

        if (this.editTool === 'node-select') {
            // Check if clicking on a node
            const node = this.getNodeAtPoint(x, y, el);
            if (node) {
                this.selectedNode = node;
                this.isDraggingNode = true;
                this.nodeStartPos = { x: node.x, y: node.y };
                document.getElementById('nodeX').value = Math.round(node.x);
                document.getElementById('nodeY').value = Math.round(node.y);
                document.getElementById('nodeType').value = node.type;
                this.renderEditMode();
            } else {
                this.selectedNode = null;
                this.renderEditMode();
            }
        } else if (this.editTool === 'add-node') {
            // Add node at click position
            this.addNodeToPath(x, y, el);
        } else if (this.editTool === 'delete-node') {
            // Delete node at click position
            const node = this.getNodeAtPoint(x, y, el);
            if (node) {
                this.deleteNodeFromPath(node, el);
            }
        } else if (['smooth-brush', 'expand-brush', 'shrink-brush'].includes(this.editTool)) {
            // Start brush stroke
            this.isBrushing = true;
            this.applyBrush(x, y, el);
        }
    }

    getNodeAtPoint(x, y, el) {
        if (!el._editNodes) return null;
        const hitRadius = 8;
        for (const node of el._editNodes) {
            const dx = x - node.x;
            const dy = y - node.y;
            if (dx * dx + dy * dy < hitRadius * hitRadius) {
                return node;
            }
        }
        return null;
    }

    addNodeToPath(x, y, el) {
        if (el.type !== 'polygon' || !el._editNodes) return;

        // Find the closest edge and insert node
        let minDist = Infinity;
        let insertIndex = 0;

        for (let i = 0; i < el._editNodes.length; i++) {
            const p1 = el._editNodes[i];
            const p2 = el._editNodes[(i + 1) % el._editNodes.length];
            const dist = this.pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
            if (dist < minDist) {
                minDist = dist;
                insertIndex = i + 1;
            }
        }

        el._editNodes.splice(insertIndex, 0, { x, y, type: 'corner' });
        this.rebuildPolygonFromNodes(el);
    }

    deleteNodeFromPath(node, el) {
        if (el.type !== 'polygon' || !el._editNodes) return;
        if (el._editNodes.length <= 3) return; // Need at least 3 points

        const index = el._editNodes.indexOf(node);
        if (index > -1) {
            el._editNodes.splice(index, 1);
            this.rebuildPolygonFromNodes(el);
        }
    }

    pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = lenSq !== 0 ? dot / lenSq : -1;

        let xx, yy;
        if (param < 0) {
            xx = x1; yy = y1;
        } else if (param > 1) {
            xx = x2; yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    applyBrush(x, y, el) {
        if (!el._editNodes) return;

        const radius = this.brushRadius;
        const strength = this.brushStrength;

        el._editNodes.forEach(node => {
            const dx = node.x - x;
            const dy = node.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < radius) {
                // Calculate falloff
                let falloff;
                if (this.brushFalloff === 'hard') {
                    falloff = 1;
                } else if (this.brushFalloff === 'linear') {
                    falloff = 1 - dist / radius;
                } else { // soft
                    falloff = Math.cos((dist / radius) * Math.PI / 2);
                }

                const effect = strength * falloff;

                if (this.editTool === 'smooth-brush') {
                    // Smooth towards center of brush
                    node.x += (x - node.x) * effect * 0.1;
                    node.y += (y - node.y) * effect * 0.1;
                } else if (this.editTool === 'expand-brush') {
                    // Push outward from brush center
                    const pushDist = effect * 2;
                    if (dist > 0) {
                        node.x += (dx / dist) * pushDist;
                        node.y += (dy / dist) * pushDist;
                    }
                } else if (this.editTool === 'shrink-brush') {
                    // Pull toward brush center
                    const pullDist = effect * 2;
                    if (dist > 0) {
                        node.x -= (dx / dist) * pullDist;
                        node.y -= (dy / dist) * pullDist;
                    }
                }
            }
        });

        this.rebuildPolygonFromNodes(el);
    }

    handleEditModeMouseMove(x, y, e) {
        const el = this.selectedElements[0];
        if (!el) return;

        // Handle node dragging
        if (this.isDraggingNode && this.selectedNode) {
            this.selectedNode.x = x;
            this.selectedNode.y = y;
            document.getElementById('nodeX').value = Math.round(x);
            document.getElementById('nodeY').value = Math.round(y);
            this.rebuildPolygonFromNodes(el);
        }

        // Handle brush stroking
        if (this.isBrushing && ['smooth-brush', 'expand-brush', 'shrink-brush'].includes(this.editTool)) {
            this.applyBrush(x, y, el);
        }

        // Draw brush cursor preview
        if (['smooth-brush', 'expand-brush', 'shrink-brush'].includes(this.editTool)) {
            this.drawBrushCursor(x, y);
        }
    }

    handleEditModeMouseUp(x, y, e) {
        if (this.isDraggingNode) {
            this.isDraggingNode = false;
            this.saveToHistory();
        }
        if (this.isBrushing) {
            this.isBrushing = false;
            this.saveToHistory();
        }
    }

    drawBrushCursor(x, y) {
        // Draw brush radius preview on selection canvas
        this.selectionCtx.save();

        // First redraw nodes if element selected
        if (this.selectedElements.length === 1) {
            const el = this.selectedElements[0];
            if (el.type === 'path' || el.type === 'polygon') {
                this.drawPathNodes(el);
            }
        }

        // Then draw brush cursor
        this.selectionCtx.beginPath();
        this.selectionCtx.arc(x, y, this.brushRadius, 0, Math.PI * 2);
        this.selectionCtx.strokeStyle = 'rgba(99, 102, 241, 0.5)';
        this.selectionCtx.lineWidth = 2;
        this.selectionCtx.setLineDash([5, 5]);
        this.selectionCtx.stroke();
        this.selectionCtx.setLineDash([]);
        this.selectionCtx.restore();
    }

    selectTool(tool) {
        this.currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tool === tool);
        });
        
        const cursors = {
            select: 'default',
            pen: 'crosshair',
            rectangle: 'crosshair',
            ellipse: 'crosshair',
            polygon: 'crosshair',
            star: 'crosshair',
            line: 'crosshair',
            text: 'text',
            eyedropper: 'crosshair',
            hand: 'grab',
            zoom: 'zoom-in'
        };
        this.canvas.style.cursor = cursors[tool] || 'default';
    }

    // ==================== POINTER EVENTS (Pen Tablet Support) ====================

    handlePointerDown(e) {
        // Store pressure information
        this.currentPressure = e.pressure || 0.5;
        this.pointerType = e.pointerType; // 'mouse', 'pen', or 'touch'

        // Capture pointer for continuous tracking
        this.canvas.setPointerCapture(e.pointerId);

        // Call the existing mouse handler
        this.handleMouseDown(e);
    }

    handlePointerMove(e) {
        // Update pressure - use e.pressure if available, otherwise default
        this.currentPressure = e.pressure || 0.5;
        this.pointerType = e.pointerType;

        // Call the existing mouse handler
        this.handleMouseMove(e);
    }

    handlePointerUp(e) {
        this.currentPressure = 0;

        // Release pointer capture
        try {
            this.canvas.releasePointerCapture(e.pointerId);
        } catch (err) {}

        // Call the existing mouse handler
        this.handleMouseUp(e);
    }

    // Get stroke width based on pressure
    getPressureWidth() {
        if (!this.penPressureEnabled || this.pointerType !== 'pen') {
            return this.currentStroke.width;
        }

        const pressure = this.currentPressure;
        return this.penMinWidth + (this.penMaxWidth - this.penMinWidth) * pressure;
    }

    // Draw pressure-sensitive stroke preview
    drawPressureStrokePreview() {
        const points = this.penPoints;
        if (points.length < 2) return;

        this.selectionCtx.fillStyle = this.currentStroke.color;

        for (let i = 1; i < points.length; i++) {
            const p0 = points[i - 1];
            const p1 = points[i];

            // Calculate widths based on pressure with taper
            let w0 = this.penMinWidth + (this.penMaxWidth - this.penMinWidth) * (p0.pressure || 0.5);
            let w1 = this.penMinWidth + (this.penMaxWidth - this.penMinWidth) * (p1.pressure || 0.5);

            // Apply taper at start
            const totalPoints = points.length;
            const taperStartPoints = Math.floor(totalPoints * this.penTaperStart);
            if (i <= taperStartPoints && taperStartPoints > 0) {
                const taperFactor = i / taperStartPoints;
                w0 *= taperFactor;
                w1 *= Math.min(1, (i + 1) / taperStartPoints);
            }

            // Apply taper at end
            const taperEndPoints = Math.floor(totalPoints * this.penTaperEnd);
            const endIndex = totalPoints - i;
            if (endIndex <= taperEndPoints && taperEndPoints > 0) {
                const taperFactor = endIndex / taperEndPoints;
                w1 *= taperFactor;
                w0 *= Math.min(1, (endIndex + 1) / taperEndPoints);
            }

            // Draw segment as filled quad
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            const len = Math.sqrt(dx * dx + dy * dy);

            if (len > 0) {
                const nx = -dy / len;
                const ny = dx / len;

                this.selectionCtx.beginPath();
                this.selectionCtx.moveTo(p0.x + nx * w0 / 2, p0.y + ny * w0 / 2);
                this.selectionCtx.lineTo(p1.x + nx * w1 / 2, p1.y + ny * w1 / 2);
                this.selectionCtx.lineTo(p1.x - nx * w1 / 2, p1.y - ny * w1 / 2);
                this.selectionCtx.lineTo(p0.x - nx * w0 / 2, p0.y - ny * w0 / 2);
                this.selectionCtx.closePath();
                this.selectionCtx.fill();

                // Draw round caps
                this.selectionCtx.beginPath();
                this.selectionCtx.arc(p0.x, p0.y, w0 / 2, 0, Math.PI * 2);
                this.selectionCtx.fill();
            }
        }

        // Final cap
        if (points.length > 0) {
            const lastPoint = points[points.length - 1];
            let w = this.penMinWidth + (this.penMaxWidth - this.penMinWidth) * (lastPoint.pressure || 0.5);

            // Apply end taper
            const taperEndPoints = Math.floor(points.length * this.penTaperEnd);
            if (taperEndPoints > 0) {
                w *= 0;
            }

            this.selectionCtx.beginPath();
            this.selectionCtx.arc(lastPoint.x, lastPoint.y, Math.max(w / 2, 0.5), 0, Math.PI * 2);
            this.selectionCtx.fill();
        }
    }

    switchPanelTab(tab) {
        document.querySelectorAll('.panel-tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === tab);
        });
        document.querySelectorAll('.tab-content').forEach(c => {
            c.classList.toggle('active', c.dataset.tab === tab);
        });
    }
    
    // ==================== CANVAS EVENTS ====================
    
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.zoom - this.pan.x;
        const y = (e.clientY - rect.top) / this.zoom - this.pan.y;

        if (this.currentTool === 'hand' || e.button === 1) {
            this.isPanning = true;
            this.panStart = { x: e.clientX - this.pan.x * this.zoom, y: e.clientY - this.pan.y * this.zoom };
            this.canvas.style.cursor = 'grabbing';
            return;
        }

        if (this.currentTool === 'zoom') {
            this.setZoom(e.shiftKey ? this.zoom / 1.5 : this.zoom * 1.5);
            return;
        }

        // Handle Edit Mode interactions
        if (this.currentMode === 'edit') {
            this.handleEditModeMouseDown(x, y, e);
            return;
        }

        if (this.currentTool === 'select') {
            // Check if clicking on a resize or rotation handle first
            if (this.selectedElements.length === 1) {
                const handle = this.getHandleAtPoint(x, y);
                if (handle) {
                    const el = this.selectedElements[0];
                    const bbox = this.getElementBBox(el);

                    if (handle.isRotation) {
                        // Start rotation
                        this.isRotating = true;
                        this.rotateHandle = handle;
                        const centerX = bbox.x + bbox.width / 2;
                        const centerY = bbox.y + bbox.height / 2;
                        this.rotateStart = {
                            x, y,
                            centerX, centerY,
                            startAngle: Math.atan2(y - centerY, x - centerX),
                            element: JSON.parse(JSON.stringify(el)),
                            originalRotation: el.rotation || 0
                        };
                        this.canvas.style.cursor = 'grabbing';
                        return;
                    }

                    this.isResizing = true;
                    this.resizeHandle = handle;
                    this.resizeStart = {
                        x, y,
                        element: JSON.parse(JSON.stringify(el)),
                        bbox: bbox
                    };
                    this.canvas.style.cursor = handle.cursor;
                    return;
                }
            }

            const clicked = this.getElementAtPoint(x, y);
            if (clicked) {
                if (!this.selectedElements.includes(clicked)) {
                    this.selectedElements = [clicked];
                }
                this.isDragging = true;
                this.dragStart = { x, y };
                this.updatePropertiesPanel();
            } else {
                this.selectedElements = [];
                this.updatePropertiesPanel();
            }
            this.render();
            this.updateLayersList();
            return;
        }
        
        if (this.currentTool === 'eyedropper') {
            // Use canvas coordinates (x, y already transformed)
            const pixelX = Math.max(0, Math.min(this.canvasWidth - 1, Math.round(x)));
            const pixelY = Math.max(0, Math.min(this.canvasHeight - 1, Math.round(y)));
            const imageData = this.ctx.getImageData(pixelX, pixelY, 1, 1);
            const color = this.rgbToHex(imageData.data[0], imageData.data[1], imageData.data[2]);
            this.currentFill.color = color;
            document.getElementById('fillSwatchInner').style.background = color;
            document.getElementById('fillColorHex').value = color;
            document.getElementById('fillColorPicker').value = color;
            this.showToast(`Color picked: ${color}`, 'success');
            return;
        }

        // Pen/freehand tool
        if (this.currentTool === 'pen') {
            this.isDrawingPen = true;
            this.penPoints = [{ x, y }];
            return;
        }

        // Text tool
        if (this.currentTool === 'text') {
            this.createTextElement(x, y);
            return;
        }

        if (['rectangle', 'ellipse', 'line', 'polygon', 'star'].includes(this.currentTool)) {
            this.isDrawing = true;
            this.drawStart = { x, y };
        }
    }
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.zoom - this.pan.x;
        const y = (e.clientY - rect.top) / this.zoom - this.pan.y;

        // Store mouse event for feedback displays
        this.lastMouseEvent = e;

        // Update cursor position display
        document.getElementById('cursorCoords').textContent = `X: ${Math.round(x)} Y: ${Math.round(y)}`;

        if (this.isPanning) {
            this.pan.x = (e.clientX - this.panStart.x) / this.zoom;
            this.pan.y = (e.clientY - this.panStart.y) / this.zoom;
            this.render();
            return;
        }

        // Handle Edit Mode interactions
        if (this.currentMode === 'edit') {
            this.handleEditModeMouseMove(x, y, e);
            return;
        }

        // Handle resizing
        if (this.isResizing && this.selectedElements.length === 1) {
            this.resizeElement(x, y, e.shiftKey);
            return;
        }

        // Handle rotation
        if (this.isRotating && this.selectedElements.length === 1) {
            this.rotateElement(x, y);
            return;
        }

        // Update cursor when hovering over handles
        if (this.currentTool === 'select' && this.selectedElements.length === 1) {
            const handle = this.getHandleAtPoint(x, y);
            if (handle) {
                this.canvas.style.cursor = handle.cursor;
            } else if (this.getElementAtPoint(x, y)) {
                this.canvas.style.cursor = 'move';
            } else {
                this.canvas.style.cursor = 'default';
            }
        }

        if (this.isDragging && this.selectedElements.length > 0) {
            let dx = x - this.dragStart.x;
            let dy = y - this.dragStart.y;

            // Shift-key: lock to horizontal or vertical axis
            if (e.shiftKey) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    dy = 0;
                } else {
                    dx = 0;
                }
            }

            // Calculate snap and smart guides
            const snapResult = this.calculateSmartGuides(dx, dy);
            dx = snapResult.dx;
            dy = snapResult.dy;

            this.selectedElements.forEach(el => this.moveElement(el, dx, dy));

            this.dragStart.x += dx;
            this.dragStart.y += dy;
            this.render();
            this.drawSmartGuides(snapResult.guides);
            this.updatePropertiesPanel();
            return;
        }

        // Pen tool drawing with pressure sensitivity
        if (this.isDrawingPen && this.currentTool === 'pen') {
            // Store point with pressure data
            const pressure = this.currentPressure || 0.5;
            this.penPoints.push({ x, y, pressure, timestamp: Date.now() });
            this.render();

            // Draw preview of pen stroke with variable width
            this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

            if (this.penPressureEnabled && this.pointerType === 'pen' && this.penPoints.length > 1) {
                // Draw variable-width stroke using filled shapes
                this.drawPressureStrokePreview();
            } else {
                // Standard fixed-width stroke
                this.selectionCtx.beginPath();
                this.selectionCtx.strokeStyle = this.currentStroke.color;
                this.selectionCtx.lineWidth = this.currentStroke.width;
                this.selectionCtx.lineCap = 'round';
                this.selectionCtx.lineJoin = 'round';
                this.selectionCtx.moveTo(this.penPoints[0].x, this.penPoints[0].y);
                for (let i = 1; i < this.penPoints.length; i++) {
                    this.selectionCtx.lineTo(this.penPoints[i].x, this.penPoints[i].y);
                }
                this.selectionCtx.stroke();
            }
            return;
        }

        if (this.isDrawing) {
            this.render();
            this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            
            const width = x - this.drawStart.x;
            const height = y - this.drawStart.y;
            
            this.selectionCtx.strokeStyle = '#6366f1';
            this.selectionCtx.lineWidth = 1;
            this.selectionCtx.setLineDash([5, 5]);
            
            // Apply shift-key constraints
            let drawWidth = width;
            let drawHeight = height;
            let drawX = x;
            let drawY = y;

            if (e.shiftKey) {
                if (this.currentTool === 'rectangle') {
                    // Lock to square
                    const size = Math.max(Math.abs(width), Math.abs(height));
                    drawWidth = width >= 0 ? size : -size;
                    drawHeight = height >= 0 ? size : -size;
                } else if (this.currentTool === 'ellipse') {
                    // Lock to circle
                    const size = Math.max(Math.abs(width), Math.abs(height));
                    drawWidth = width >= 0 ? size : -size;
                    drawHeight = height >= 0 ? size : -size;
                } else if (this.currentTool === 'line') {
                    // Constrain to 0°, 45°, 90° angles
                    const dx = x - this.drawStart.x;
                    const dy = y - this.drawStart.y;
                    const angle = Math.atan2(dy, dx);
                    const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    drawX = this.drawStart.x + Math.cos(snapAngle) * distance;
                    drawY = this.drawStart.y + Math.sin(snapAngle) * distance;
                } else if (this.currentTool === 'polygon' || this.currentTool === 'star') {
                    // Lock to square bounding box
                    const size = Math.max(Math.abs(width), Math.abs(height));
                    drawWidth = width >= 0 ? size : -size;
                    drawHeight = height >= 0 ? size : -size;
                }
            }

            if (this.currentTool === 'rectangle') {
                this.selectionCtx.strokeRect(this.drawStart.x, this.drawStart.y, drawWidth, drawHeight);
            } else if (this.currentTool === 'ellipse') {
                this.selectionCtx.beginPath();
                this.selectionCtx.ellipse(
                    this.drawStart.x + drawWidth / 2,
                    this.drawStart.y + drawHeight / 2,
                    Math.abs(drawWidth / 2),
                    Math.abs(drawHeight / 2),
                    0, 0, Math.PI * 2
                );
                this.selectionCtx.stroke();
            } else if (this.currentTool === 'line') {
                this.selectionCtx.beginPath();
                this.selectionCtx.moveTo(this.drawStart.x, this.drawStart.y);
                this.selectionCtx.lineTo(drawX, drawY);
                this.selectionCtx.stroke();
            } else if (this.currentTool === 'polygon') {
                // Polygon preview
                const sides = 6;
                const radius = Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight) / 2;
                const cx = this.drawStart.x + drawWidth / 2;
                const cy = this.drawStart.y + drawHeight / 2;

                this.selectionCtx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
                    const px = cx + radius * Math.cos(angle);
                    const py = cy + radius * Math.sin(angle);
                    if (i === 0) {
                        this.selectionCtx.moveTo(px, py);
                    } else {
                        this.selectionCtx.lineTo(px, py);
                    }
                }
                this.selectionCtx.closePath();
                this.selectionCtx.stroke();
            } else if (this.currentTool === 'star') {
                // Star preview
                const numPoints = 5;
                const outerRadius = Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight) / 2;
                const innerRadius = outerRadius * 0.4;
                const cx = this.drawStart.x + drawWidth / 2;
                const cy = this.drawStart.y + drawHeight / 2;

                this.selectionCtx.beginPath();
                for (let i = 0; i < numPoints * 2; i++) {
                    const angle = (i * Math.PI / numPoints) - Math.PI / 2;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = cx + r * Math.cos(angle);
                    const py = cy + r * Math.sin(angle);
                    if (i === 0) {
                        this.selectionCtx.moveTo(px, py);
                    } else {
                        this.selectionCtx.lineTo(px, py);
                    }
                }
                this.selectionCtx.closePath();
                this.selectionCtx.stroke();
            }

            // Store constrained values for use in mouseUp
            this.constrainedDraw = { width: drawWidth, height: drawHeight, x: drawX, y: drawY };
        }
    }
    
    handleMouseUp(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.zoom - this.pan.x;
        const y = (e.clientY - rect.top) / this.zoom - this.pan.y;

        if (this.isPanning) {
            this.isPanning = false;
            this.canvas.style.cursor = this.currentTool === 'hand' ? 'grab' : 'default';
            return;
        }

        // Handle Edit Mode mouse up
        if (this.currentMode === 'edit') {
            this.handleEditModeMouseUp(x, y, e);
            return;
        }

        // Finish resizing
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            this.canvas.style.cursor = 'default';
            this.render();
            this.updatePropertiesPanel();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
            return;
        }

        // Finish rotating
        if (this.isRotating) {
            this.isRotating = false;
            this.rotateHandle = null;
            this.rotateStart = null;
            this.canvas.style.cursor = 'default';
            this.render();
            this.updatePropertiesPanel();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
            return;
        }

        if (this.isDragging) {
            this.isDragging = false;
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
            return;
        }

        // Finish pen tool stroke
        if (this.isDrawingPen && this.penPoints.length > 1) {
            this.isDrawingPen = false;
            this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

            // Simplify path for smoother curves
            const simplified = this.simplifyPenPath(this.penPoints, 2);
            const pathData = this.penPointsToSVGPath(simplified);

            const element = {
                id: 'path_' + Date.now(),
                type: 'path',
                d: pathData,
                fill: { type: 'none', color: '#000000', alpha: 1 },
                stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                opacity: 1,
                name: 'Pen Path'
            };
            element.stroke.enabled = true;

            this.elements.push(element);
            this.selectedElements = [element];
            this.penPoints = [];
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.updatePropertiesPanel();
            this.saveToHistory();
            this.saveToLocalStorage();
            return;
        }

        if (this.isDrawing) {
            this.isDrawing = false;
            this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

            // Use constrained values from mouse move if available
            const width = this.constrainedDraw ? this.constrainedDraw.width : (x - this.drawStart.x);
            const height = this.constrainedDraw ? this.constrainedDraw.height : (y - this.drawStart.y);
            const endX = this.constrainedDraw ? this.constrainedDraw.x : x;
            const endY = this.constrainedDraw ? this.constrainedDraw.y : y;

            // Clear constrained draw values
            this.constrainedDraw = null;

            if (Math.abs(width) < 5 && Math.abs(height) < 5) return;

            let element = null;

            if (this.currentTool === 'rectangle') {
                element = {
                    id: 'rect_' + Date.now(),
                    type: 'rect',
                    x: width >= 0 ? this.drawStart.x : this.drawStart.x + width,
                    y: height >= 0 ? this.drawStart.y : this.drawStart.y + height,
                    width: Math.abs(width),
                    height: Math.abs(height),
                    rx: 0,
                    fill: JSON.parse(JSON.stringify(this.currentFill)),
                    stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                    opacity: 1,
                    name: 'Rectangle'
                };
            } else if (this.currentTool === 'ellipse') {
                element = {
                    id: 'ellipse_' + Date.now(),
                    type: 'ellipse',
                    cx: this.drawStart.x + width / 2,
                    cy: this.drawStart.y + height / 2,
                    rx: Math.abs(width / 2),
                    ry: Math.abs(height / 2),
                    fill: JSON.parse(JSON.stringify(this.currentFill)),
                    stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                    opacity: 1,
                    name: 'Ellipse'
                };
            } else if (this.currentTool === 'line') {
                element = {
                    id: 'line_' + Date.now(),
                    type: 'line',
                    x1: this.drawStart.x,
                    y1: this.drawStart.y,
                    x2: endX,
                    y2: endY,
                    stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                    opacity: 1,
                    name: 'Line'
                };
                element.stroke.enabled = true;
            } else if (this.currentTool === 'polygon') {
                const sides = 6;
                const radius = Math.sqrt(width * width + height * height) / 2;
                const cx = this.drawStart.x + width / 2;
                const cy = this.drawStart.y + height / 2;

                let points = '';
                for (let i = 0; i < sides; i++) {
                    const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
                    const px = cx + radius * Math.cos(angle);
                    const py = cy + radius * Math.sin(angle);
                    points += `${px},${py} `;
                }

                element = {
                    id: 'polygon_' + Date.now(),
                    type: 'polygon',
                    points: points.trim(),
                    fill: JSON.parse(JSON.stringify(this.currentFill)),
                    stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                    opacity: 1,
                    name: 'Polygon'
                };
            } else if (this.currentTool === 'star') {
                const numPoints = 5;
                const outerRadius = Math.sqrt(width * width + height * height) / 2;
                const innerRadius = outerRadius * 0.4;
                const cx = this.drawStart.x + width / 2;
                const cy = this.drawStart.y + height / 2;

                let starPoints = '';
                for (let i = 0; i < numPoints * 2; i++) {
                    const angle = (i * Math.PI / numPoints) - Math.PI / 2;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = cx + r * Math.cos(angle);
                    const py = cy + r * Math.sin(angle);
                    starPoints += `${px},${py} `;
                }

                element = {
                    id: 'star_' + Date.now(),
                    type: 'polygon',
                    points: starPoints.trim(),
                    fill: JSON.parse(JSON.stringify(this.currentFill)),
                    stroke: JSON.parse(JSON.stringify(this.currentStroke)),
                    opacity: 1,
                    name: 'Star'
                };
            }
            
            if (element) {
                if (this.currentFill.type === 'linear' || this.currentFill.type === 'radial') {
                    element.gradient = JSON.parse(JSON.stringify(this.currentGradient));
                }

                this.elements.push(element);
                this.selectedElements = [element];
                this.render();
                this.updateLayersList();
                this.updateCodeEditor();
                this.updatePropertiesPanel();
                this.saveToHistory();
                this.saveToLocalStorage();
            }
        }
    }

    handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.setZoom(this.zoom * delta);
    }
    
    handleContextMenu(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.zoom - this.pan.x;
        const y = (e.clientY - rect.top) / this.zoom - this.pan.y;
        
        const clicked = this.getElementAtPoint(x, y);
        if (clicked) {
            if (!this.selectedElements.includes(clicked)) {
                this.selectedElements = [clicked];
            }
            this.render();
            this.showContextMenu(e.clientX, e.clientY);
        }
    }
    
    showContextMenu(x, y) {
        const menu = document.getElementById('contextMenu');
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.classList.add('active');
    }
    
    hideContextMenu() {
        document.getElementById('contextMenu').classList.remove('active');
    }
    
    handleContextAction(action) {
        if (this.selectedElements.length === 0) return;
        
        switch (action) {
            case 'duplicate':
                const duplicates = this.selectedElements.map(el => {
                    const dup = JSON.parse(JSON.stringify(el));
                    dup.id = el.type + '_' + Date.now();
                    if (dup.x !== undefined) dup.x += 20;
                    if (dup.y !== undefined) dup.y += 20;
                    if (dup.cx !== undefined) dup.cx += 20;
                    if (dup.cy !== undefined) dup.cy += 20;
                    return dup;
                });
                this.elements.push(...duplicates);
                this.selectedElements = duplicates;
                break;
            case 'delete':
                this.selectedElements.forEach(el => {
                    const index = this.elements.indexOf(el);
                    if (index > -1) this.elements.splice(index, 1);
                });
                this.selectedElements = [];
                break;
            case 'bringFront':
                this.selectedElements.forEach(el => {
                    const index = this.elements.indexOf(el);
                    if (index > -1) {
                        this.elements.splice(index, 1);
                        this.elements.push(el);
                    }
                });
                break;
            case 'sendBack':
                this.selectedElements.forEach(el => {
                    const index = this.elements.indexOf(el);
                    if (index > -1) {
                        this.elements.splice(index, 1);
                        this.elements.unshift(el);
                    }
                });
                break;
        }
        
        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.saveToHistory();
        this.saveToLocalStorage();
    }

    getElementAtPoint(x, y) {
        for (let i = this.elements.length - 1; i >= 0; i--) {
            const el = this.elements[i];
            // Skip hidden elements
            if (el.visible === false) continue;
            if (this.isPointInElement(x, y, el)) {
                return el;
            }
        }
        return null;
    }
    
    isPointInElement(x, y, el) {
        switch (el.type) {
            case 'rect':
                return x >= el.x && x <= el.x + el.width && y >= el.y && y <= el.y + el.height;
            case 'ellipse':
                const dx = (x - el.cx) / el.rx;
                const dy = (y - el.cy) / el.ry;
                return dx * dx + dy * dy <= 1;
            case 'line':
                return this.pointToLineDistance(x, y, el.x1, el.y1, el.x2, el.y2) < 10;
            case 'polygon':
                return this.isPointInPolygon(x, y, el.points);
            case 'path':
                const bbox = this.getPathBBox(el.d);
                return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
            case 'text':
                const textBbox = this.getElementBBox(el);
                return x >= textBbox.x && x <= textBbox.x + textBbox.width && y >= textBbox.y && y <= textBbox.y + textBbox.height;
            default:
                return false;
        }
    }

    pointToLineDistance(x, y, x1, y1, x2, y2) {
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = len_sq !== 0 ? dot / len_sq : -1;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy));
    }
    
    isPointInPolygon(x, y, pointsStr) {
        const points = pointsStr.split(' ').map(p => {
            const [px, py] = p.split(',').map(Number);
            return { x: px, y: py };
        });
        
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;
            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }
    
    getPathBBox(d) {
        const nums = d.match(/-?\d+\.?\d*/g) || [];
        if (nums.length < 2) return { x: 0, y: 0, width: 100, height: 100 };
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let i = 0; i < nums.length - 1; i += 2) {
            const x = parseFloat(nums[i]);
            const y = parseFloat(nums[i + 1]);
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
        }
        
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    
    // ==================== RENDERING ====================
    
    render() {
        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        this.ctx.fillStyle = 'white';
        this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

        this.elements.forEach(el => {
            // Skip hidden elements
            if (el.visible === false) return;

            this.ctx.save();
            this.ctx.globalAlpha = el.opacity || 1;
            
            if (el.fill && el.fill.type !== 'none') {
                if (el.gradient && (el.fill.type === 'linear' || el.fill.type === 'radial')) {
                    this.ctx.fillStyle = this.createCanvasGradient(el);
                } else {
                    const alpha = el.fill.alpha !== undefined ? el.fill.alpha : 1;
                    this.ctx.fillStyle = this.hexToRgba(el.fill.color, alpha);
                }
            }
            
            if (el.stroke && el.stroke.enabled) {
                this.ctx.strokeStyle = el.stroke.color;
                this.ctx.lineWidth = el.stroke.width;
                this.ctx.lineCap = el.stroke.linecap || 'round';
                this.ctx.lineJoin = el.stroke.linejoin || 'round';
                
                if (el.stroke.style === 'dashed') {
                    this.ctx.setLineDash([10, 5]);
                } else if (el.stroke.style === 'dotted') {
                    this.ctx.setLineDash([2, 3]);
                } else {
                    this.ctx.setLineDash([]);
                }
            }

            // Apply rotation if element has rotation property
            if (el.rotation) {
                const bbox = this.getElementBBox(el);
                const centerX = bbox.x + bbox.width / 2;
                const centerY = bbox.y + bbox.height / 2;
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(el.rotation * Math.PI / 180);
                this.ctx.translate(-centerX, -centerY);
            }

            // Apply shadow effect
            if (el.shadow && el.shadow.enabled) {
                this.ctx.shadowOffsetX = el.shadow.x || 4;
                this.ctx.shadowOffsetY = el.shadow.y || 4;
                this.ctx.shadowBlur = el.shadow.blur || 8;
                const rgb = this.hexToRgb(el.shadow.color || '#000000');
                this.ctx.shadowColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${el.shadow.opacity || 0.3})`;
            }

            // Apply blur effect
            if (el.blur && el.blur.enabled) {
                this.ctx.filter = `blur(${el.blur.amount || 5}px)`;
            }

            this.drawElement(el);
            this.ctx.restore();
        });

        // Draw selection or edit mode overlay
        if (this.currentMode === 'edit') {
            this.renderEditMode();
        } else {
            this.drawSelection();
        }
        this.updateAlignToolbar();
    }

    createCanvasGradient(el) {
        const grad = el.gradient;
        let canvasGrad;
        
        if (grad.type === 'linear') {
            const angle = grad.angle * Math.PI / 180;
            let x1, y1, x2, y2;
            
            if (el.type === 'rect') {
                const cx = el.x + el.width / 2;
                const cy = el.y + el.height / 2;
                const size = Math.max(el.width, el.height);
                x1 = cx - Math.cos(angle) * size / 2;
                y1 = cy - Math.sin(angle) * size / 2;
                x2 = cx + Math.cos(angle) * size / 2;
                y2 = cy + Math.sin(angle) * size / 2;
            } else if (el.type === 'ellipse') {
                const size = Math.max(el.rx, el.ry) * 2;
                x1 = el.cx - Math.cos(angle) * size / 2;
                y1 = el.cy - Math.sin(angle) * size / 2;
                x2 = el.cx + Math.cos(angle) * size / 2;
                y2 = el.cy + Math.sin(angle) * size / 2;
            } else {
                x1 = 0; y1 = 0; x2 = this.canvasWidth; y2 = 0;
            }
            
            canvasGrad = this.ctx.createLinearGradient(x1, y1, x2, y2);
        } else {
            let cx, cy, r;
            if (el.type === 'rect') {
                cx = el.x + el.width / 2;
                cy = el.y + el.height / 2;
                r = Math.max(el.width, el.height) / 2;
            } else if (el.type === 'ellipse') {
                cx = el.cx;
                cy = el.cy;
                r = Math.max(el.rx, el.ry);
            } else {
                cx = this.canvasWidth / 2;
                cy = this.canvasHeight / 2;
                r = Math.max(this.canvasWidth, this.canvasHeight) / 2;
            }
            canvasGrad = this.ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        }
        
        grad.stops.forEach(stop => {
            canvasGrad.addColorStop(stop.offset, stop.color);
        });
        
        return canvasGrad;
    }
    
    drawElement(el) {
        switch (el.type) {
            case 'rect':
                if (el.rx > 0) {
                    this.roundRect(el.x, el.y, el.width, el.height, el.rx);
                } else {
                    this.ctx.beginPath();
                    this.ctx.rect(el.x, el.y, el.width, el.height);
                }
                if (el.fill && el.fill.type !== 'none') this.ctx.fill();
                if (el.stroke && el.stroke.enabled) this.ctx.stroke();
                break;
            case 'ellipse':
                this.ctx.beginPath();
                this.ctx.ellipse(el.cx, el.cy, el.rx, el.ry, 0, 0, Math.PI * 2);
                if (el.fill && el.fill.type !== 'none') this.ctx.fill();
                if (el.stroke && el.stroke.enabled) this.ctx.stroke();
                break;
            case 'line':
                this.ctx.beginPath();
                this.ctx.moveTo(el.x1, el.y1);
                this.ctx.lineTo(el.x2, el.y2);
                if (el.stroke && el.stroke.enabled) this.ctx.stroke();
                break;
            case 'polygon':
                const points = el.points.split(' ').map(p => {
                    const [x, y] = p.split(',').map(Number);
                    return { x, y };
                });
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                points.slice(1).forEach(p => this.ctx.lineTo(p.x, p.y));
                this.ctx.closePath();
                if (el.fill && el.fill.type !== 'none') this.ctx.fill();
                if (el.stroke && el.stroke.enabled) this.ctx.stroke();
                break;
            case 'path':
                const path = new Path2D(el.d);
                if (el.fill && el.fill.type !== 'none') this.ctx.fill(path);
                if (el.stroke && el.stroke.enabled) this.ctx.stroke(path);
                break;
            case 'text':
                this.ctx.font = `${el.fontSize || 24}px ${el.fontFamily || 'Plus Jakarta Sans'}`;
                this.ctx.textBaseline = 'top';
                if (el.fill && el.fill.type !== 'none') {
                    this.ctx.fillText(el.text, el.x, el.y);
                }
                if (el.stroke && el.stroke.enabled) {
                    this.ctx.strokeText(el.text, el.x, el.y);
                }
                break;
            case 'group':
                if (el.children && el.children.length > 0) {
                    el.children.forEach(child => {
                        this.ctx.save();
                        this.ctx.globalAlpha = child.opacity || 1;

                        if (child.fill && child.fill.type !== 'none') {
                            if (child.gradient && (child.fill.type === 'linear' || child.fill.type === 'radial')) {
                                this.ctx.fillStyle = this.createCanvasGradient(child);
                            } else {
                                const alpha = child.fill.alpha !== undefined ? child.fill.alpha : 1;
                                this.ctx.fillStyle = this.hexToRgba(child.fill.color, alpha);
                            }
                        }

                        if (child.stroke && child.stroke.enabled) {
                            this.ctx.strokeStyle = child.stroke.color;
                            this.ctx.lineWidth = child.stroke.width;
                            this.ctx.lineCap = child.stroke.linecap || 'round';
                            this.ctx.lineJoin = child.stroke.linejoin || 'round';

                            if (child.stroke.style === 'dashed') {
                                this.ctx.setLineDash([10, 5]);
                            } else if (child.stroke.style === 'dotted') {
                                this.ctx.setLineDash([2, 3]);
                            } else {
                                this.ctx.setLineDash([]);
                            }
                        }

                        this.drawElement(child);
                        this.ctx.restore();
                    });
                }
                break;
        }
    }
    
    roundRect(x, y, w, h, r) {
        this.ctx.beginPath();
        this.ctx.moveTo(x + r, y);
        this.ctx.lineTo(x + w - r, y);
        this.ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        this.ctx.lineTo(x + w, y + h - r);
        this.ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        this.ctx.lineTo(x + r, y + h);
        this.ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        this.ctx.lineTo(x, y + r);
        this.ctx.quadraticCurveTo(x, y, x + r, y);
        this.ctx.closePath();
    }
    
    drawSelection() {
        // Always clear selection canvas first
        this.selectionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

        if (this.selectedElements.length === 0) return;

        this.selectionCtx.strokeStyle = '#6366f1';
        this.selectionCtx.lineWidth = 2;
        this.selectionCtx.setLineDash([]);

        this.selectedElements.forEach(el => {
            const bbox = this.getElementBBox(el);
            const padding = 4;
            const handleSize = 8;
            this.selectionCtx.fillStyle = 'white';

            // Special handling for lines - show endpoint handles instead of bbox
            if (el.type === 'line') {
                // Draw the selection line highlight
                this.selectionCtx.beginPath();
                this.selectionCtx.setLineDash([6, 4]);
                this.selectionCtx.moveTo(el.x1, el.y1);
                this.selectionCtx.lineTo(el.x2, el.y2);
                this.selectionCtx.stroke();
                this.selectionCtx.setLineDash([]);

                // Line endpoint handles
                this.selectionHandles = [
                    { id: 'lineStart', x: el.x1, y: el.y1, cursor: 'crosshair', isLineEndpoint: true },
                    { id: 'lineEnd', x: el.x2, y: el.y2, cursor: 'crosshair', isLineEndpoint: true }
                ];

                // Draw circular endpoint handles
                this.selectionHandles.forEach(h => {
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(h.x, h.y, handleSize / 2 + 2, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                    // Draw inner dot
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(h.x, h.y, 2, 0, Math.PI * 2);
                    this.selectionCtx.fillStyle = '#6366f1';
                    this.selectionCtx.fill();
                    this.selectionCtx.fillStyle = 'white';
                });
                return;
            }

            this.selectionCtx.strokeRect(
                bbox.x - padding,
                bbox.y - padding,
                bbox.width + padding * 2,
                bbox.height + padding * 2
            );

            // Rotation handle position (above center)
            const rotateDistance = 25;
            const rotateCenterX = bbox.x + bbox.width / 2;
            const rotateCenterY = bbox.y - padding - rotateDistance;

            // Draw rotation handle connection line
            this.selectionCtx.beginPath();
            this.selectionCtx.setLineDash([3, 3]);
            this.selectionCtx.moveTo(bbox.x + bbox.width / 2, bbox.y - padding);
            this.selectionCtx.lineTo(rotateCenterX, rotateCenterY);
            this.selectionCtx.stroke();
            this.selectionCtx.setLineDash([]);

            // Corner handles: nw, ne, se, sw
            // Edge handles: n, e, s, w
            // Rotation handle: rotate
            this.selectionHandles = [
                { id: 'nw', x: bbox.x - padding, y: bbox.y - padding, cursor: 'nwse-resize' },
                { id: 'n', x: bbox.x + bbox.width / 2, y: bbox.y - padding, cursor: 'ns-resize' },
                { id: 'ne', x: bbox.x + bbox.width + padding, y: bbox.y - padding, cursor: 'nesw-resize' },
                { id: 'e', x: bbox.x + bbox.width + padding, y: bbox.y + bbox.height / 2, cursor: 'ew-resize' },
                { id: 'se', x: bbox.x + bbox.width + padding, y: bbox.y + bbox.height + padding, cursor: 'nwse-resize' },
                { id: 's', x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height + padding, cursor: 'ns-resize' },
                { id: 'sw', x: bbox.x - padding, y: bbox.y + bbox.height + padding, cursor: 'nesw-resize' },
                { id: 'w', x: bbox.x - padding, y: bbox.y + bbox.height / 2, cursor: 'ew-resize' },
                { id: 'rotate', x: rotateCenterX, y: rotateCenterY, cursor: 'grab', isRotation: true }
            ];

            this.selectionHandles.forEach(h => {
                if (h.isRotation) {
                    // Draw circular rotation handle
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(h.x, h.y, handleSize / 2 + 2, 0, Math.PI * 2);
                    this.selectionCtx.fill();
                    this.selectionCtx.stroke();
                    // Draw rotation icon (curved arrow)
                    this.selectionCtx.beginPath();
                    this.selectionCtx.arc(h.x, h.y, handleSize / 2 - 1, -Math.PI * 0.7, Math.PI * 0.3);
                    this.selectionCtx.strokeStyle = '#6366f1';
                    this.selectionCtx.lineWidth = 1.5;
                    this.selectionCtx.stroke();
                    this.selectionCtx.strokeStyle = '#6366f1';
                    this.selectionCtx.lineWidth = 2;
                } else {
                    this.selectionCtx.fillRect(h.x - handleSize / 2, h.y - handleSize / 2, handleSize, handleSize);
                    this.selectionCtx.strokeRect(h.x - handleSize / 2, h.y - handleSize / 2, handleSize, handleSize);
                }
            });
        });
    }

    getHandleAtPoint(x, y) {
        if (!this.selectionHandles) return null;
        const handleSize = 10; // Slightly larger hit area
        for (const h of this.selectionHandles) {
            if (h.isRotation || h.isLineEndpoint) {
                // Circular hit area for rotation handle and line endpoints
                const dist = Math.sqrt((x - h.x) ** 2 + (y - h.y) ** 2);
                if (dist <= handleSize) return h;
            } else {
                if (x >= h.x - handleSize / 2 && x <= h.x + handleSize / 2 &&
                    y >= h.y - handleSize / 2 && y <= h.y + handleSize / 2) {
                    return h;
                }
            }
        }
        return null;
    }

    resizeElement(x, y, shiftKey = false) {
        const el = this.selectedElements[0];
        const start = this.resizeStart;
        const handle = this.resizeHandle.id;
        const dx = x - start.x;
        const dy = y - start.y;
        const orig = start.element;
        const bbox = start.bbox;

        // Special handling for line endpoint dragging
        if (handle === 'lineStart' || handle === 'lineEnd') {
            let newX = x, newY = y;

            // Shift key constrains to 45-degree angles
            if (shiftKey) {
                const otherX = handle === 'lineStart' ? el.x2 : el.x1;
                const otherY = handle === 'lineStart' ? el.y2 : el.y1;
                const deltaX = x - otherX;
                const deltaY = y - otherY;
                const angle = Math.atan2(deltaY, deltaX);
                const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                newX = otherX + Math.cos(snappedAngle) * dist;
                newY = otherY + Math.sin(snappedAngle) * dist;
            }

            if (handle === 'lineStart') {
                el.x1 = newX;
                el.y1 = newY;
            } else {
                el.x2 = newX;
                el.y2 = newY;
            }
            this.render();
            this.updatePropertiesPanel();
            return;
        }

        // Calculate new bounds based on handle
        let newX = bbox.x, newY = bbox.y, newW = bbox.width, newH = bbox.height;

        switch (handle) {
            case 'nw':
                newX = bbox.x + dx;
                newY = bbox.y + dy;
                newW = bbox.width - dx;
                newH = bbox.height - dy;
                break;
            case 'n':
                newY = bbox.y + dy;
                newH = bbox.height - dy;
                break;
            case 'ne':
                newY = bbox.y + dy;
                newW = bbox.width + dx;
                newH = bbox.height - dy;
                break;
            case 'e':
                newW = bbox.width + dx;
                break;
            case 'se':
                newW = bbox.width + dx;
                newH = bbox.height + dy;
                break;
            case 's':
                newH = bbox.height + dy;
                break;
            case 'sw':
                newX = bbox.x + dx;
                newW = bbox.width - dx;
                newH = bbox.height + dy;
                break;
            case 'w':
                newX = bbox.x + dx;
                newW = bbox.width - dx;
                break;
        }

        // Shift-key: maintain aspect ratio
        if (shiftKey && bbox.width > 0 && bbox.height > 0) {
            const aspectRatio = bbox.width / bbox.height;

            // Determine which dimension to constrain based on handle
            if (handle === 'n' || handle === 's') {
                // Vertical handle - adjust width to match
                newW = newH * aspectRatio;
                newX = bbox.x + (bbox.width - newW) / 2;
            } else if (handle === 'e' || handle === 'w') {
                // Horizontal handle - adjust height to match
                newH = newW / aspectRatio;
                newY = bbox.y + (bbox.height - newH) / 2;
            } else {
                // Corner handle - use the larger delta
                const deltaW = newW - bbox.width;
                const deltaH = newH - bbox.height;

                if (Math.abs(deltaW) > Math.abs(deltaH * aspectRatio)) {
                    newH = newW / aspectRatio;
                    if (handle.includes('n')) {
                        newY = bbox.y + bbox.height - newH;
                    }
                } else {
                    newW = newH * aspectRatio;
                    if (handle.includes('w')) {
                        newX = bbox.x + bbox.width - newW;
                    }
                }
            }
        }

        // Ensure minimum size
        if (newW < 10) { newW = 10; if (handle.includes('w')) newX = bbox.x + bbox.width - 10; }
        if (newH < 10) { newH = 10; if (handle.includes('n')) newY = bbox.y + bbox.height - 10; }

        // Apply to element based on type
        switch (el.type) {
            case 'rect':
            case 'text':
                el.x = newX;
                el.y = newY;
                el.width = newW;
                el.height = newH;
                break;
            case 'ellipse':
                el.cx = newX + newW / 2;
                el.cy = newY + newH / 2;
                el.rx = newW / 2;
                el.ry = newH / 2;
                break;
            case 'line':
                // Scale line endpoints
                const scaleX = newW / bbox.width;
                const scaleY = newH / bbox.height;
                el.x1 = newX + (orig.x1 - bbox.x) * scaleX;
                el.y1 = newY + (orig.y1 - bbox.y) * scaleY;
                el.x2 = newX + (orig.x2 - bbox.x) * scaleX;
                el.y2 = newY + (orig.y2 - bbox.y) * scaleY;
                break;
            case 'polygon':
                // Scale polygon points
                const points = orig.points.split(' ').map(p => {
                    const [px, py] = p.split(',').map(Number);
                    const sx = newW / bbox.width;
                    const sy = newH / bbox.height;
                    const npx = newX + (px - bbox.x) * sx;
                    const npy = newY + (py - bbox.y) * sy;
                    return `${npx},${npy}`;
                });
                el.points = points.join(' ');
                break;
        }

        this.render();
        this.updatePropertiesPanel();
    }

    rotateElement(x, y) {
        const el = this.selectedElements[0];
        const start = this.rotateStart;

        // Calculate current angle from center
        const currentAngle = Math.atan2(y - start.centerY, x - start.centerX);
        const deltaAngle = currentAngle - start.startAngle;

        // Convert to degrees and snap to 15-degree increments when Shift is held
        let degrees = (deltaAngle * 180 / Math.PI);

        // Apply rotation
        el.rotation = (start.originalRotation + degrees) % 360;

        // Display rotation angle feedback - use stored mouse position
        this.showRotationFeedback(el.rotation, this.lastMouseEvent);
        this.render();
        this.updatePropertiesPanel();
    }

    showRotationFeedback(angle, mouseEvent) {
        // Create or update rotation feedback tooltip
        let feedback = document.getElementById('rotationFeedback');
        if (!feedback) {
            feedback = document.createElement('div');
            feedback.id = 'rotationFeedback';
            feedback.style.cssText = `
                position: fixed;
                background: var(--bg-panel);
                color: var(--text);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                font-family: var(--font-mono);
                pointer-events: none;
                z-index: 1000;
                border: 1px solid var(--accent);
            `;
            document.body.appendChild(feedback);
        }
        feedback.textContent = `${Math.round(angle)}°`;
        feedback.style.display = 'block';
        if (mouseEvent) {
            feedback.style.left = (mouseEvent.clientX + 15) + 'px';
            feedback.style.top = (mouseEvent.clientY + 15) + 'px';
        }

        // Hide after rotation ends
        clearTimeout(this.rotationFeedbackTimeout);
        this.rotationFeedbackTimeout = setTimeout(() => {
            feedback.style.display = 'none';
        }, 500);
    }

    getElementBBox(el) {
        switch (el.type) {
            case 'rect':
                return { x: el.x, y: el.y, width: el.width, height: el.height };
            case 'ellipse':
                return { x: el.cx - el.rx, y: el.cy - el.ry, width: el.rx * 2, height: el.ry * 2 };
            case 'line':
                return {
                    x: Math.min(el.x1, el.x2),
                    y: Math.min(el.y1, el.y2),
                    width: Math.abs(el.x2 - el.x1),
                    height: Math.abs(el.y2 - el.y1)
                };
            case 'polygon':
                const points = el.points.split(' ').map(p => {
                    const [x, y] = p.split(',').map(Number);
                    return { x, y };
                });
                const xs = points.map(p => p.x);
                const ys = points.map(p => p.y);
                return {
                    x: Math.min(...xs),
                    y: Math.min(...ys),
                    width: Math.max(...xs) - Math.min(...xs),
                    height: Math.max(...ys) - Math.min(...ys)
                };
            case 'path':
                return this.getPathBBox(el.d);
            case 'text':
                // Measure text width using canvas context
                this.ctx.font = `${el.fontSize || 24}px ${el.fontFamily || 'Plus Jakarta Sans'}`;
                const metrics = this.ctx.measureText(el.text);
                return {
                    x: el.x,
                    y: el.y,
                    width: metrics.width,
                    height: el.fontSize || 24
                };
            case 'group':
                if (!el.children || el.children.length === 0) {
                    return { x: 0, y: 0, width: 100, height: 100 };
                }
                const childBboxes = el.children.map(c => this.getElementBBox(c));
                const minGX = Math.min(...childBboxes.map(b => b.x));
                const minGY = Math.min(...childBboxes.map(b => b.y));
                const maxGX = Math.max(...childBboxes.map(b => b.x + b.width));
                const maxGY = Math.max(...childBboxes.map(b => b.y + b.height));
                return {
                    x: minGX,
                    y: minGY,
                    width: maxGX - minGX,
                    height: maxGY - minGY
                };
            default:
                return { x: 0, y: 0, width: 100, height: 100 };
        }
    }
    
    // ==================== ZOOM ====================
    
    setZoom(zoom) {
        this.zoom = Math.max(0.1, Math.min(10, zoom));
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
        this.render();
    }
    
    fitToCanvas() {
        const container = document.getElementById('canvasArea');
        const scaleX = (container.clientWidth - 100) / this.canvasWidth;
        const scaleY = (container.clientHeight - 100) / this.canvasHeight;
        this.setZoom(Math.min(scaleX, scaleY));
    }
    
    // ==================== LAYERS ====================
    
    updateLayersList() {
        const list = document.getElementById('layersList');
        list.innerHTML = '';

        [...this.elements].reverse().forEach((el, i) => {
            const actualIndex = this.elements.length - 1 - i;
            const isSelected = this.selectedElements.includes(el);
            const isVisible = el.visible !== false;

            const item = document.createElement('div');
            item.className = 'layer-item' + (isSelected ? ' selected' : '') + (!isVisible ? ' hidden-layer' : '');
            item.draggable = true;
            item.dataset.index = actualIndex;
            item.innerHTML = `
                <div class="layer-drag-handle" title="Drag to reorder">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="20" y2="18"/>
                    </svg>
                </div>
                <button class="layer-visibility-btn ${isVisible ? 'visible' : ''}" data-action="toggle-visibility" title="${isVisible ? 'Hide' : 'Show'}">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        ${isVisible
                            ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                            : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>'
                        }
                    </svg>
                </button>
                <div class="layer-preview">
                    ${this.getLayerPreviewSVG(el)}
                </div>
                <div class="layer-info">
                    <div class="layer-name">${el.name || el.type}</div>
                    <div class="layer-type">${el.type}</div>
                </div>
                <div class="layer-actions">
                    <button class="layer-action-btn" data-action="delete" title="Delete">✕</button>
                </div>
            `;

            // Drag and drop handlers
            item.addEventListener('dragstart', (e) => {
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', actualIndex);
                this.draggedLayerIndex = actualIndex;
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                document.querySelectorAll('.layer-item').forEach(li => {
                    li.classList.remove('drag-over', 'drag-over-below');
                });
                this.draggedLayerIndex = null;
            });

            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                // Determine if dropping above or below
                const rect = item.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;

                // Clear other indicators
                document.querySelectorAll('.layer-item').forEach(li => {
                    if (li !== item) li.classList.remove('drag-over', 'drag-over-below');
                });

                if (e.clientY < midY) {
                    item.classList.add('drag-over');
                    item.classList.remove('drag-over-below');
                } else {
                    item.classList.add('drag-over-below');
                    item.classList.remove('drag-over');
                }
            });

            item.addEventListener('dragleave', (e) => {
                // Only remove if leaving the item entirely
                if (!item.contains(e.relatedTarget)) {
                    item.classList.remove('drag-over', 'drag-over-below');
                }
            });

            item.addEventListener('drop', (e) => {
                e.preventDefault();
                item.classList.remove('drag-over', 'drag-over-below');

                const fromIndex = this.draggedLayerIndex;
                let toIndex = actualIndex;

                // Adjust for drop position (above or below)
                const rect = item.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                if (e.clientY >= midY) {
                    toIndex = Math.max(0, toIndex - 1);
                }

                if (fromIndex !== null && fromIndex !== toIndex) {
                    // Move element in array
                    const [movedEl] = this.elements.splice(fromIndex, 1);
                    this.elements.splice(toIndex, 0, movedEl);

                    this.render();
                    this.updateLayersList();
                    this.updateCodeEditor();
                    this.saveToHistory();
                    this.saveToLocalStorage();
                }
            });

            item.addEventListener('click', (e) => {
                if (e.target.closest('.layer-action-btn') || e.target.closest('.layer-visibility-btn') || e.target.closest('.layer-drag-handle')) return;
                this.selectedElements = [el];
                this.render();
                this.updateLayersList();
                this.updatePropertiesPanel();
            });

            const visBtn = item.querySelector('[data-action="toggle-visibility"]');
            visBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                el.visible = !isVisible;
                this.render();
                this.updateLayersList();
                this.saveToHistory();
                this.saveToLocalStorage();
            });

            const delBtn = item.querySelector('[data-action="delete"]');
            delBtn.addEventListener('click', () => {
                this.elements.splice(actualIndex, 1);
                if (this.selectedElements.includes(el)) {
                    this.selectedElements = [];
                }
                this.render();
                this.updateLayersList();
                this.updateCodeEditor();
                this.saveToHistory();
                this.saveToLocalStorage();
            });

            list.appendChild(item);
        });
    }
    
    getLayerPreviewSVG(el) {
        const size = 24;
        let svg = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">`;
        
        const fill = el.fill && el.fill.type !== 'none' ? el.fill.color : 'none';
        const stroke = el.stroke && el.stroke.enabled ? el.stroke.color : 'none';
        const strokeWidth = el.stroke && el.stroke.enabled ? Math.min(el.stroke.width, 2) : 0;
        
        switch (el.type) {
            case 'rect':
                svg += `<rect x="4" y="4" width="16" height="16" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>`;
                break;
            case 'ellipse':
                svg += `<ellipse cx="12" cy="12" rx="8" ry="6" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>`;
                break;
            case 'line':
                svg += `<line x1="4" y1="20" x2="20" y2="4" stroke="${el.stroke.color}" stroke-width="2"/>`;
                break;
            case 'polygon':
                svg += `<polygon points="12,4 20,20 4,20" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>`;
                break;
            case 'path':
                svg += `<path d="M4 12 Q12 4 20 12 Q12 20 4 12" fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>`;
                break;
        }
        
        svg += '</svg>';
        return svg;
    }
    
    addNewShape() {
        this.selectTool('rectangle');
        this.showToast('Selected Rectangle tool. Click and drag on canvas to draw.', 'success');
    }
    
    // ==================== PROPERTIES ====================
    
    updatePropertiesPanel() {
        if (this.selectedElements.length === 0) return;

        const el = this.selectedElements[0];
        const bbox = this.getElementBBox(el);

        // Update number inputs
        document.getElementById('propX').value = Math.round(bbox.x);
        document.getElementById('propY').value = Math.round(bbox.y);
        document.getElementById('propW').value = Math.round(bbox.width);
        document.getElementById('propH').value = Math.round(bbox.height);
        document.getElementById('propRotation').value = el.rotation || 0;
        document.getElementById('propOpacity').value = (el.opacity || 1) * 100;
        document.getElementById('opacityValue').textContent = Math.round((el.opacity || 1) * 100) + '%';

        // Update sliders to match number inputs
        document.getElementById('propXSlider').value = Math.round(bbox.x);
        document.getElementById('propYSlider').value = Math.round(bbox.y);
        document.getElementById('propWSlider').value = Math.round(bbox.width);
        document.getElementById('propHSlider').value = Math.round(bbox.height);
        document.getElementById('propRotationSlider').value = el.rotation || 0;

        if (el.fill) {
            document.getElementById('fillType').value = el.fill.type;
            if (el.fill.type === 'solid') {
                document.getElementById('fillSwatchInner').style.background = el.fill.color;
                document.getElementById('fillColorHex').value = el.fill.color;
                document.getElementById('fillColorPicker').value = el.fill.color;
                document.getElementById('fillAlpha').value = (el.fill.alpha || 1) * 100;
                document.getElementById('fillAlphaValue').textContent = Math.round((el.fill.alpha || 1) * 100) + '%';
            }
            this.currentFill = JSON.parse(JSON.stringify(el.fill));
            this.updateFillUI();
        }

        if (el.stroke) {
            document.getElementById('strokeToggle').classList.toggle('active', el.stroke.enabled);
            document.getElementById('strokeSwatchInner').style.background = el.stroke.color;
            document.getElementById('strokeColorHex').value = el.stroke.color;
            document.getElementById('strokeColorPicker').value = el.stroke.color;
            document.getElementById('strokeWidth').value = el.stroke.width;
            this.currentStroke = JSON.parse(JSON.stringify(el.stroke));
        }

        if (el.gradient) {
            this.currentGradient = JSON.parse(JSON.stringify(el.gradient));
            this.updateGradientUI();
        }

        document.getElementById('cornerRadiusProp').classList.toggle('hidden', el.type !== 'rect');
        if (el.type === 'rect') {
            document.getElementById('propCornerRadius').value = el.rx || 0;
            document.getElementById('propCornerRadiusSlider').value = el.rx || 0;
        }

        // Update effects UI
        this.updateEffectsUI(el);
    }

    updateSelectedFromProps() {
        if (this.selectedElements.length === 0) return;
        
        const el = this.selectedElements[0];
        const newX = parseFloat(document.getElementById('propX').value);
        const newY = parseFloat(document.getElementById('propY').value);
        const newW = parseFloat(document.getElementById('propW').value);
        const newH = parseFloat(document.getElementById('propH').value);
        const opacity = parseFloat(document.getElementById('propOpacity').value) / 100;
        
        el.opacity = opacity;
        
        switch (el.type) {
            case 'rect':
                el.x = newX;
                el.y = newY;
                el.width = newW;
                el.height = newH;
                el.rx = parseFloat(document.getElementById('propCornerRadius').value) || 0;
                break;
            case 'ellipse':
                el.cx = newX + newW / 2;
                el.cy = newY + newH / 2;
                el.rx = newW / 2;
                el.ry = newH / 2;
                break;
        }
        
        this.render();
        this.updateCodeEditor();
    }
    
    updateSelected() {
        if (this.selectedElements.length === 0) return;
        
        this.selectedElements.forEach(el => {
            el.fill = JSON.parse(JSON.stringify(this.currentFill));
            el.stroke = JSON.parse(JSON.stringify(this.currentStroke));
            if (this.currentFill.type === 'linear' || this.currentFill.type === 'radial') {
                el.gradient = JSON.parse(JSON.stringify(this.currentGradient));
            }
        });
        
        this.render();
        this.updateCodeEditor();
    }
    
    // ==================== CODE EDITOR ====================
    
    updateCodeEditor() {
        const code = this.generateSVG();
        document.getElementById('codeEditor').textContent = code;
    }
    
    generateSVG(optimized = false) {
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${this.canvasWidth} ${this.canvasHeight}" width="${this.canvasWidth}" height="${this.canvasHeight}">`;
        if (!optimized) svg += '\n';

        // Collect all definitions (gradients, filters)
        const defs = [];

        // Gradients
        const gradients = [];
        this.elements.forEach((el, i) => {
            if (el.gradient && (el.fill.type === 'linear' || el.fill.type === 'radial')) {
                gradients.push({ id: `grad_${i}`, element: el });
            }
        });

        gradients.forEach(g => {
            const grad = g.element.gradient;
            const stops = grad.stops.map(s =>
                `<stop offset="${s.offset * 100}%" stop-color="${s.color}"/>`
            ).join(optimized ? '' : '\n      ');

            if (grad.type === 'linear') {
                const angle = grad.angle * Math.PI / 180;
                const x1 = Math.round(50 - Math.cos(angle) * 50);
                const y1 = Math.round(50 - Math.sin(angle) * 50);
                const x2 = Math.round(50 + Math.cos(angle) * 50);
                const y2 = Math.round(50 + Math.sin(angle) * 50);

                defs.push(optimized
                    ? `<linearGradient id="${g.id}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">${stops}</linearGradient>`
                    : `    <linearGradient id="${g.id}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">\n      ${stops}\n    </linearGradient>`);
            } else {
                defs.push(optimized
                    ? `<radialGradient id="${g.id}">${stops}</radialGradient>`
                    : `    <radialGradient id="${g.id}">\n      ${stops}\n    </radialGradient>`);
            }
        });

        // Filters for shadow and blur
        this.elements.forEach((el, i) => {
            if ((el.shadow && el.shadow.enabled) || (el.blur && el.blur.enabled)) {
                let filterContent = '';
                if (el.shadow && el.shadow.enabled) {
                    const rgb = this.hexToRgb(el.shadow.color || '#000000');
                    filterContent += `<feDropShadow dx="${el.shadow.x || 4}" dy="${el.shadow.y || 4}" stdDeviation="${(el.shadow.blur || 8) / 2}" flood-color="rgb(${rgb.r},${rgb.g},${rgb.b})" flood-opacity="${el.shadow.opacity || 0.3}"/>`;
                }
                if (el.blur && el.blur.enabled) {
                    filterContent += `<feGaussianBlur stdDeviation="${el.blur.amount || 5}"/>`;
                }
                defs.push(optimized
                    ? `<filter id="filter_${i}">${filterContent}</filter>`
                    : `    <filter id="filter_${i}">\n      ${filterContent}\n    </filter>`);
            }
        });

        if (defs.length > 0) {
            svg += optimized ? '<defs>' + defs.join('') + '</defs>' : '  <defs>\n' + defs.join('\n') + '\n  </defs>\n';
        }

        // Elements
        this.elements.forEach((el, i) => {
            svg += this.elementToSVG(el, i, optimized, '  ');
        });

        svg += '</svg>';
        return svg;
    }

    elementToSVG(el, index, optimized, indent = '') {
        const attrs = [];

        if (el.fill) {
            if (el.fill.type === 'none') {
                attrs.push('fill="none"');
            } else if (el.gradient && (el.fill.type === 'linear' || el.fill.type === 'radial')) {
                attrs.push(`fill="url(#grad_${index})"`);
            } else {
                const alpha = el.fill.alpha !== undefined ? el.fill.alpha : 1;
                if (alpha < 1) {
                    attrs.push(`fill="${el.fill.color}" fill-opacity="${alpha}"`);
                } else {
                    attrs.push(`fill="${el.fill.color}"`);
                }
            }
        }

        if (el.stroke && el.stroke.enabled) {
            attrs.push(`stroke="${el.stroke.color}"`);
            attrs.push(`stroke-width="${el.stroke.width}"`);
            if (el.stroke.linecap && el.stroke.linecap !== 'butt') attrs.push(`stroke-linecap="${el.stroke.linecap}"`);
            if (el.stroke.linejoin && el.stroke.linejoin !== 'miter') attrs.push(`stroke-linejoin="${el.stroke.linejoin}"`);
            if (el.stroke.style === 'dashed') attrs.push('stroke-dasharray="10,5"');
            if (el.stroke.style === 'dotted') attrs.push('stroke-dasharray="2,3"');
        } else if (el.type !== 'line' && el.type !== 'group') {
            attrs.push('stroke="none"');
        }

        if (el.opacity !== undefined && el.opacity < 1) {
            attrs.push(`opacity="${el.opacity}"`);
        }

        // Filter for shadow/blur
        if ((el.shadow && el.shadow.enabled) || (el.blur && el.blur.enabled)) {
            attrs.push(`filter="url(#filter_${index})"`);
        }

        // Rotation transform
        if (el.rotation) {
            const bbox = this.getElementBBox(el);
            const cx = bbox.x + bbox.width / 2;
            const cy = bbox.y + bbox.height / 2;
            attrs.push(`transform="rotate(${el.rotation} ${cx} ${cy})"`);
        }

        let elementSvg = '';
        switch (el.type) {
            case 'rect':
                elementSvg = `<rect x="${el.x}" y="${el.y}" width="${el.width}" height="${el.height}"`;
                if (el.rx > 0) elementSvg += ` rx="${el.rx}"`;
                elementSvg += ` ${attrs.join(' ')}/>`;
                break;
            case 'ellipse':
                elementSvg = `<ellipse cx="${el.cx}" cy="${el.cy}" rx="${el.rx}" ry="${el.ry}" ${attrs.join(' ')}/>`;
                break;
            case 'line':
                elementSvg = `<line x1="${el.x1}" y1="${el.y1}" x2="${el.x2}" y2="${el.y2}" ${attrs.join(' ')}/>`;
                break;
            case 'polygon':
                elementSvg = `<polygon points="${el.points}" ${attrs.join(' ')}/>`;
                break;
            case 'path':
                elementSvg = `<path d="${el.d}" ${attrs.join(' ')}/>`;
                break;
            case 'text':
                const escapedText = el.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                elementSvg = `<text x="${el.x}" y="${el.y + (el.fontSize || 24)}" font-size="${el.fontSize || 24}" font-family="${el.fontFamily || 'Plus Jakarta Sans'}" ${attrs.join(' ')}>${escapedText}</text>`;
                break;
            case 'group':
                if (el.children && el.children.length > 0) {
                    let groupAttrs = attrs.length > 0 ? ' ' + attrs.join(' ') : '';
                    elementSvg = `<g${groupAttrs}>`;
                    if (!optimized) elementSvg += '\n';
                    el.children.forEach((child, childIdx) => {
                        elementSvg += this.elementToSVG(child, `${index}_${childIdx}`, optimized, indent + '  ');
                    });
                    elementSvg += optimized ? '</g>' : `${indent}</g>`;
                }
                break;
        }

        return optimized ? elementSvg : `${indent}${elementSvg}\n`;
    }
    
    copyCode() {
        const code = this.generateSVG();
        navigator.clipboard.writeText(code).then(() => {
            this.showToast('SVG code copied to clipboard!', 'success');
        });
    }
    
    formatCode() {
        this.updateCodeEditor();
        this.showToast('Code formatted', 'success');
    }
    
    // ==================== EXPORT ====================
    
    showExportModal() {
        document.getElementById('exportModal').classList.add('active');
    }
    
    hideExportModal() {
        document.getElementById('exportModal').classList.remove('active');
    }

    showHelpModal() {
        document.getElementById('helpModal').classList.add('active');
    }

    hideHelpModal() {
        document.getElementById('helpModal').classList.remove('active');
    }

    selectExportFormat(option) {
        document.querySelectorAll('.export-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        
        const format = option.dataset.format;
        document.getElementById('pngOptionsSection').style.display = format === 'png' ? 'block' : 'none';
        
        const btnText = {
            'svg': 'Download SVG',
            'png': 'Download PNG',
            'svg-optimized': 'Download Optimized SVG',
            'copy': 'Copy to Clipboard'
        };
        document.getElementById('doExportBtn').innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            ${btnText[format]}
        `;
    }
    
    doExport() {
        const format = document.querySelector('.export-option.selected').dataset.format;
        
        switch (format) {
            case 'svg': this.downloadSVG(false); break;
            case 'svg-optimized': this.downloadSVG(true); break;
            case 'png': this.downloadPNG(); break;
            case 'copy': this.copyCode(); break;
        }
        
        this.hideExportModal();
    }
    
    downloadSVG(optimized) {
        const svg = this.generateSVG(optimized);
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'design' + (optimized ? '-optimized' : '') + '.svg';
        a.click();
        URL.revokeObjectURL(url);
        this.showToast('SVG downloaded!', 'success');
    }
    
    downloadPNG() {
        const scale = parseInt(document.getElementById('pngScale').value);
        const transparent = document.getElementById('pngTransparentToggle').classList.contains('active');
        
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = this.canvasWidth * scale;
        exportCanvas.height = this.canvasHeight * scale;
        const exportCtx = exportCanvas.getContext('2d');
        
        exportCtx.scale(scale, scale);
        
        if (!transparent) {
            exportCtx.fillStyle = 'white';
            exportCtx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        }
        
        const svg = this.generateSVG();
        const img = new Image();
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        
        img.onload = () => {
            exportCtx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            
            exportCanvas.toBlob(blob => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'design.png';
                a.click();
                this.showToast('PNG downloaded!', 'success');
            }, 'image/png');
        };
        img.src = url;
    }
    
    // ==================== IMPORT / NEW ====================
    
    importSVG() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.svg';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => this.parseSVG(e.target.result);
                reader.readAsText(file);
            }
        };
        input.click();
    }
    
    parseSVG(svgString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, 'image/svg+xml');
        const svg = doc.querySelector('svg');
        
        if (!svg) {
            this.showToast('Invalid SVG file', 'error');
            return;
        }
        
        const viewBox = svg.getAttribute('viewBox');
        if (viewBox) {
            const [, , w, h] = viewBox.split(' ').map(Number);
            this.canvasWidth = w || 800;
            this.canvasHeight = h || 600;
        } else {
            this.canvasWidth = parseFloat(svg.getAttribute('width')) || 800;
            this.canvasHeight = parseFloat(svg.getAttribute('height')) || 600;
        }
        
        this.canvas.width = this.canvasWidth;
        this.canvas.height = this.canvasHeight;
        this.selectionCanvas.width = this.canvasWidth;
        this.selectionCanvas.height = this.canvasHeight;
        
        this.elements = [];
        
        svg.querySelectorAll('rect, ellipse, circle, line, polygon, polyline, path').forEach((el, i) => {
            const element = this.parseSVGElement(el, i);
            if (element) this.elements.push(element);
        });
        
        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.showToast(`Imported ${this.elements.length} elements`, 'success');
    }
    
    parseSVGElement(el, index) {
        const fill = el.getAttribute('fill');
        const stroke = el.getAttribute('stroke');
        const strokeWidth = parseFloat(el.getAttribute('stroke-width')) || 2;
        
        const fillObj = {
            type: fill === 'none' ? 'none' : 'solid',
            color: fill && fill !== 'none' ? fill : '#6366f1',
            alpha: parseFloat(el.getAttribute('fill-opacity')) || 1
        };
        
        const strokeObj = {
            enabled: stroke && stroke !== 'none',
            color: stroke || '#000000',
            width: strokeWidth,
            style: 'solid',
            linecap: el.getAttribute('stroke-linecap') || 'round',
            linejoin: el.getAttribute('stroke-linejoin') || 'round'
        };
        
        switch (el.tagName.toLowerCase()) {
            case 'rect':
                return {
                    id: 'rect_' + Date.now() + '_' + index,
                    type: 'rect',
                    x: parseFloat(el.getAttribute('x')) || 0,
                    y: parseFloat(el.getAttribute('y')) || 0,
                    width: parseFloat(el.getAttribute('width')) || 100,
                    height: parseFloat(el.getAttribute('height')) || 100,
                    rx: parseFloat(el.getAttribute('rx')) || 0,
                    fill: fillObj,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Rectangle'
                };
            case 'ellipse':
                return {
                    id: 'ellipse_' + Date.now() + '_' + index,
                    type: 'ellipse',
                    cx: parseFloat(el.getAttribute('cx')) || 50,
                    cy: parseFloat(el.getAttribute('cy')) || 50,
                    rx: parseFloat(el.getAttribute('rx')) || 50,
                    ry: parseFloat(el.getAttribute('ry')) || 50,
                    fill: fillObj,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Ellipse'
                };
            case 'circle':
                const r = parseFloat(el.getAttribute('r')) || 50;
                return {
                    id: 'ellipse_' + Date.now() + '_' + index,
                    type: 'ellipse',
                    cx: parseFloat(el.getAttribute('cx')) || 50,
                    cy: parseFloat(el.getAttribute('cy')) || 50,
                    rx: r,
                    ry: r,
                    fill: fillObj,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Circle'
                };
            case 'line':
                return {
                    id: 'line_' + Date.now() + '_' + index,
                    type: 'line',
                    x1: parseFloat(el.getAttribute('x1')) || 0,
                    y1: parseFloat(el.getAttribute('y1')) || 0,
                    x2: parseFloat(el.getAttribute('x2')) || 100,
                    y2: parseFloat(el.getAttribute('y2')) || 100,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Line'
                };
            case 'polygon':
            case 'polyline':
                return {
                    id: 'polygon_' + Date.now() + '_' + index,
                    type: 'polygon',
                    points: el.getAttribute('points') || '',
                    fill: fillObj,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Polygon'
                };
            case 'path':
                return {
                    id: 'path_' + Date.now() + '_' + index,
                    type: 'path',
                    d: el.getAttribute('d') || '',
                    fill: fillObj,
                    stroke: strokeObj,
                    opacity: parseFloat(el.getAttribute('opacity')) || 1,
                    name: 'Path'
                };
        }
        return null;
    }
    
    newDocument() {
        if (this.elements.length > 0) {
            if (!confirm('Create new document? Unsaved changes will be lost.')) return;
        }
        
        this.elements = [];
        this.selectedElements = [];
        this.canvasWidth = 800;
        this.canvasHeight = 600;
        this.canvas.width = this.canvasWidth;
        this.canvas.height = this.canvasHeight;
        this.selectionCanvas.width = this.canvasWidth;
        this.selectionCanvas.height = this.canvasHeight;
        
        this.render();
        this.updateLayersList();
        this.updateCodeEditor();
        this.showToast('New document created', 'success');
    }
    
    // ==================== KEYBOARD SHORTCUTS ====================
    
    handleKeyDown(e) {
        const toolShortcuts = {
            'v': 'select', 'p': 'pen', 'r': 'rectangle', 'e': 'ellipse',
            'l': 'line', 't': 'text', 'i': 'eyedropper', 'h': 'hand', 'z': 'zoom'
        };
        
        if (!e.ctrlKey && !e.metaKey && toolShortcuts[e.key.toLowerCase()]) {
            this.selectTool(toolShortcuts[e.key.toLowerCase()]);
            return;
        }

        // Undo: Ctrl+Z
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            this.undo();
            return;
        }

        // Redo: Ctrl+Shift+Z or Ctrl+Y
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey) || (e.key === 'Z' && e.shiftKey))) {
            e.preventDefault();
            this.redo();
            return;
        }

        if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedElements.length > 0) {
            e.preventDefault();
            this.selectedElements.forEach(el => {
                const index = this.elements.indexOf(el);
                if (index > -1) this.elements.splice(index, 1);
            });
            this.selectedElements = [];
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === 'c' && this.selectedElements.length > 0) {
            this.clipboard = this.selectedElements.map(el => JSON.parse(JSON.stringify(el)));
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === 'v' && this.clipboard) {
            const pasted = this.clipboard.map(el => {
                const newEl = JSON.parse(JSON.stringify(el));
                newEl.id = el.type + '_' + Date.now();
                if (newEl.x !== undefined) newEl.x += 20;
                if (newEl.y !== undefined) newEl.y += 20;
                if (newEl.cx !== undefined) newEl.cx += 20;
                if (newEl.cy !== undefined) newEl.cy += 20;
                return newEl;
            });
            this.elements.push(...pasted);
            this.selectedElements = pasted;
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
        }

        if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
            e.preventDefault();
            this.selectedElements = [...this.elements];
            this.render();
            this.updateLayersList();
        }

        if ((e.ctrlKey || e.metaKey) && e.key === 'd' && this.selectedElements.length > 0) {
            e.preventDefault();
            const duplicates = this.selectedElements.map(el => {
                const dup = JSON.parse(JSON.stringify(el));
                dup.id = el.type + '_' + Date.now();
                if (dup.x !== undefined) dup.x += 20;
                if (dup.y !== undefined) dup.y += 20;
                if (dup.cx !== undefined) dup.cx += 20;
                if (dup.cy !== undefined) dup.cy += 20;
                return dup;
            });
            this.elements.push(...duplicates);
            this.selectedElements = duplicates;
            this.render();
            this.updateLayersList();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            this.showExportModal();
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === '=') {
            e.preventDefault();
            this.setZoom(this.zoom * 1.25);
        }
        if ((e.ctrlKey || e.metaKey) && e.key === '-') {
            e.preventDefault();
            this.setZoom(this.zoom / 1.25);
        }
        if ((e.ctrlKey || e.metaKey) && e.key === '0') {
            e.preventDefault();
            this.setZoom(1);
        }
        
        if (e.key === 'Escape') {
            this.selectedElements = [];
            this.selectTool('select');
            this.render();
            this.updateLayersList();
            this.updatePropertiesPanel();
            this.hideContextMenu();
            this.hideExportModal();
            this.hideHelpModal();
        }

        // Arrow key nudging (1px normal, 10px with Shift)
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && this.selectedElements.length > 0) {
            e.preventDefault();
            const nudge = e.shiftKey ? 10 : 1;
            let dx = 0, dy = 0;

            switch (e.key) {
                case 'ArrowUp': dy = -nudge; break;
                case 'ArrowDown': dy = nudge; break;
                case 'ArrowLeft': dx = -nudge; break;
                case 'ArrowRight': dx = nudge; break;
            }

            this.selectedElements.forEach(el => this.moveElement(el, dx, dy));
            this.render();
            this.updateProperties();
            this.updateCodeEditor();
            this.saveToHistory();
            this.saveToLocalStorage();
        }

        // Grouping: Ctrl+G to group, Ctrl+Shift+G to ungroup
        if ((e.ctrlKey || e.metaKey) && e.key === 'g' && !e.shiftKey && this.selectedElements.length > 1) {
            e.preventDefault();
            this.groupElements();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'g' && e.shiftKey && this.selectedElements.length === 1) {
            e.preventDefault();
            this.ungroupElements();
        }

        // ? to show help
        if (e.key === '?' || (e.shiftKey && e.key === '/')) {
            e.preventDefault();
            this.showHelpModal();
        }
    }
    
    // ==================== TOAST ====================
    
    showToast(message, type = 'success') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = 'toast toast-' + type;
        toast.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${type === 'success' ? '#10b981' : '#ef4444'}" stroke-width="2">
                ${type === 'success' 
                    ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>'
                    : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'}
            </svg>
            ${message}
        `;
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    window.studio = new SVGStudio();
});
</script>
</body>
</html>
